<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<title>Fortune 1000 — Sectors Dashboard</title>

<!-- Chart.js + PapaParse -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
// CLOUD STORAGE CONFIGURATION - ADD THIS AT TOP
// DATA CONFIGURATION - Uses Cloud Run proxy for authenticated access
// The proxy endpoints in app.py fetch from private GCS bucket
function getDataUrl(path) {
  // Route to appropriate proxy endpoint based on path
  if (path.startsWith('data/')) {
    // /api/data/daily_counts/..., /api/data/processed_articles/..., etc.
    return '/api/data/' + path.substring(5);
  } else if (path.startsWith('rosters/')) {
    // /api/data/rosters/main-roster.csv
    return '/api/data/' + path;
  }
  return '/api/data/' + path;
}
// END OF CLOUD STORAGE CONFIG
</script>

<style>
:root {
  /* Palette (matches brand dashboard) */
  --bg: #044152;
  --card: #092e37;
  --muted: #a2ebf3;
  --text: #ebf2f2;
  --accent: #58dbed;
  --black: #1f2121;

  --pill-neg: #ff8261;
  --pill-neu: #cfdbdd;
  --pill-pos: #82c618;

  --stroke: #0e2230;
  --chip: #12343e;
  --chipBorder: #174550;
  
  --stock-pos:#22c55e; 
  --stock-neg:#ef4444;
}

*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
.wrap{max-width:1200px;margin:0 auto;padding:20px}
h1{font-size:28px;margin:6px 0 18px}

/* Controls */
.controls{display:flex;flex-direction:column;gap:8px;margin:0 0 16px}
.controls select,
.controls input,
.controls button{height:32px;padding:6px 10px;font-size:12px;line-height:1.2;border-radius:8px}
.controls .controls-grid{
  display:grid;
  grid-template-columns:170px 220px 190px 190px auto auto auto;
  gap:8px 12px;
  align-items:end;
  width:100%;
}
.controls .field-label{font-size:12px;margin:0;padding-left:8px;line-height:1.2}
.controls .field-label-empty{padding-left:0}
.controls .controls-inputs input,
.controls .controls-inputs select{width:100%;min-width:0}
.controls .controls-inputs button{width:auto;white-space:nowrap;justify-self:start}
.controls .controls-aux{display:flex;flex-wrap:wrap;align-items:center;gap:8px}
.controls .controls-aux .muted{font-size:12px}
.card{background:var(--card);border:1px solid var(--stroke);border-radius:12px;padding:12px 12px}
select,input[type="text"]{background:#1f2121;border:1px solid #23314d;border-radius:10px;color:var(--text);padding:8px 10px}
button{background:#1f2121;border:1px solid #2a3b5e;color:var(--text);border-radius:10px;padding:8px 12px;cursor:pointer}
button:hover{filter:brightness(1.08)}
.filter-toggle.active{border-color:#58dbed;box-shadow:0 0 0 1px rgba(88,219,237,.35);color:#58dbed}
.crisis-toggle{border-color:#7b1d1d;color:#ffb3b3}
.crisis-toggle.active{border-color:#ff4545;box-shadow:0 0 0 1px rgba(255,69,69,.4);color:#ff5c5c}
.controls .spacer{display:none}
@media (max-width: 980px){
  .controls .controls-header{display:none}
  .controls .controls-grid{grid-template-columns:1fr}
  .controls .controls-inputs button{width:100%}
}

/* Charts grid */
.grid{
  display:grid;
  grid-auto-rows:minmax(340px,40vh);
  gap:16px;
  margin:16px 0;
}
.chart-card{ background:var(--card); border:1px solid var(--stroke);
  border-radius:12px; padding:12px 12px 48px; position:relative }
.chart-card canvas{ width:100% !important; height:100% !important; display:block }
.chart-card.loading::after{
  content:"";position:absolute;left:12px;right:12px;top:54px;bottom:16px;border-radius:10px;
  background:linear-gradient(90deg,rgba(255,255,255,.05),rgba(255,255,255,.18),rgba(255,255,255,.05));
  background-size:200% 100%;animation:skeleton 1.2s ease-in-out infinite;pointer-events:none
}
.chart-card.loading canvas{opacity:.2}

/* Range + pager (top right of each chart card) */
.chart-actions{ position:absolute; top:10px; right:12px; display:flex; align-items:center; gap:10px; }
.chart-actions .dates-range{ font-size:12px; }
.chart-actions .dates-pager{ display:flex; gap:6px; }
.chart-actions .dates-pager button{
  background:#1f2121; border:1px solid #2a3b5e; color:var(--text);
  border-radius:8px; padding:4px 8px; cursor:pointer;
}
.chart-actions .dates-pager button[disabled]{ opacity:.45; cursor:not-allowed; }

/* Table */
.table-card{background:var(--card);border:1px solid var(--stroke);border-radius:12px;padding:10px}
.table-hint{margin:0 0 8px;color:var(--muted)}
.load-status{margin-top:10px;width:100%;display:flex;flex-direction:column;align-items:center}
.load-bar{height:6px;background:rgba(255,255,255,.08);border-radius:999px;overflow:hidden}
.load-bar-fill{height:100%;width:0%;background:var(--accent);transition:width .2s ease}
.load-items{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;font-size:12px;color:var(--muted);justify-content:center;text-align:center}
.load-pill{padding:2px 8px;border-radius:999px;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.1)}
.load-pill.done{color:#82c618;border-color:rgba(130,198,24,.35);background:rgba(130,198,24,.1)}
.load-pill.error{color:#ff8261;border-color:rgba(255,130,97,.35);background:rgba(255,130,97,.1)}
table{width:100%;border-collapse:separate;border-spacing:0 6px}
thead th{font-size:11px;color:var(--muted);text-align:center;padding:6px 4px;vertical-align:middle;line-height:1.3;white-space:normal;max-width:100px}
thead th:nth-child(2){text-align:left;max-width:140px}
tbody td{padding:8px 4px;background:#1f2121;border-top:1px solid #0f1831;border-bottom:1px solid #0f1831;text-align:center}
tbody td:nth-child(2){text-align:left;max-width:140px;white-space:normal}
tbody tr td:first-child{border-left:1px solid #0f1831;border-radius:10px 0 0 10px}
tbody tr td:last-child{border-right:1px solid #0f1831;border-radius:0 10px 10px 0}
.skeleton-row td{padding:10px 12px}
.skeleton-bar{height:12px;border-radius:8px;background:linear-gradient(90deg,rgba(255,255,255,.05),rgba(255,255,255,.2),rgba(255,255,255,.05));background-size:200% 100%;animation:skeleton 1.2s ease-in-out infinite}
.skeleton-bar.full{width:100%;height:16px}

/* Stock styling */
.stock-change{font-weight:600}
.stock-change.positive{color:var(--stock-pos)}
.stock-change.negative{color:var(--stock-neg)}

/* Mobile horizontal scroll */
.table-scroll{ overflow-x:auto; -webkit-overflow-scrolling:touch }
.table-scroll::-webkit-scrollbar{height:8px}
.table-scroll::-webkit-scrollbar-track{background:rgba(255,255,255,.05);border-radius:8px}
.table-scroll::-webkit-scrollbar-thumb{background:rgba(255,255,255,.12);border-radius:8px}
@media (max-width: 960px){
  .table-card{ padding:8px }
  thead th, tbody td{ padding:8px 10px }
  table{ min-width: 980px }
}
/* Pagination */
.pagination{display:flex;gap:8px;align-items:center;justify-content:flex-end;margin-top:8px}

/* Utilities */
.muted{color:var(--muted)}

/* Tooltips */
.tooltip-header {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted #a2ebf3;
  cursor: help;
}

.tooltip-header .tooltip-text {
  visibility: hidden;
  width: 240px;
  background-color: #1f2121;
  color: #ebf2f2;
  text-align: left;
  border: 1px solid #2a3b5e;
  border-radius: 8px;
  padding: 10px 12px;
  position: absolute;
  z-index: 1000;
  top: 125%;
  left: 50%;
  margin-left: -120px;
  opacity: 0;
  transition: opacity 0.3s ease;
  font-size: 12px;
  line-height: 1.5;
  font-weight: normal;
  white-space: normal;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
}

.tooltip-header .tooltip-text::after {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #1f2121 transparent;
}

.tooltip-header:hover .tooltip-text {
  visibility: visible;
  opacity: 1;
}

@media (max-width: 768px) {
  .tooltip-header .tooltip-text {
    width: 200px;
    margin-left: -100px;
    font-size: 11px;
  }
}

@keyframes skeleton{0%{background-position:200% 0}100%{background-position:-200% 0}}

</style>
</head>

<body>
<div class="wrap">
  <h1>Fortune 1000 — Sectors Dashboard</h1>

  <div class="controls card">
    <div class="controls-grid controls-header">
      <div class="muted field-label">Date</div>
      <div class="muted field-label">Filter (Sector)</div>
      <div class="muted field-label">Sector</div>
      <div class="muted field-label">Company Size</div>
      <div class="field-label field-label-empty" aria-hidden="true"></div>
      <div class="field-label field-label-empty" aria-hidden="true"></div>
      <div class="field-label field-label-empty" aria-hidden="true"></div>
    </div>
    <div class="controls-grid controls-inputs">
      <select id="dateSelect"></select>
      <input id="filterInput" type="text" placeholder="Type to filter…" />
      <select id="sectorFilterSelect" title="Filter by sector">
        <option value="">All sectors</option>
      </select>
      <select id="companySizeSelect">
        <option value="all">All companies</option>
        <option value="fortune500">Fortune 500</option>
        <option value="fortune1000">Fortune 1000</option>
        <option value="forbes">Forbes</option>
      </select>
      <button id="clearBtn">Clear Selection</button>
      <button id="crisisBtn" class="filter-toggle crisis-toggle" title="Only sectors with at least one company with a negative Top stories URL">Crisis</button>
      <button id="refreshBtn">Refresh Data</button>
    </div>
    <div class="controls-aux">
      <span id="refreshStatus" class="muted"></span>
    </div>
    <div class="load-status" id="loadStatus">
      <div class="load-bar"><div class="load-bar-fill" id="loadBarFill"></div></div>
      <div class="load-items" id="loadItems"></div>
    </div>
  </div>

  <div class="grid">
    <div class="chart-card loading" data-chart="features">
      <h3>SERP Feature Negativity (stacked)</h3>
      <div class="chart-actions">
        <span class="dates-range muted" aria-live="polite"></span>
        <div class="dates-pager">
          <button class="dates-prev" title="Older window">←</button>
          <button class="dates-next" title="Newer window">→</button>
        </div>
      </div>
      <canvas id="featureChart"></canvas>
    </div>
    <div class="chart-card loading" data-chart="features">
      <h3>SERP Feature Control (stacked)</h3>
      <div class="chart-actions">
        <span class="dates-range muted" aria-live="polite"></span>
        <div class="dates-pager">
          <button class="dates-prev" title="Older window">←</button>
          <button class="dates-next" title="Newer window">→</button>
        </div>
      </div>
      <canvas id="featureControlChart"></canvas>
    </div>
    <div class="chart-card loading" data-chart="news">
      <h3>News sentiment (percent of articles)</h3>
      <div class="chart-actions">
        <span class="dates-range muted" aria-live="polite"></span>
        <div class="dates-pager">
          <button class="dates-prev" title="Older window">←</button>
          <button class="dates-next" title="Newer window">→</button>
        </div>
      </div>
      <canvas id="newsChart"></canvas>
    </div>
    <div class="chart-card loading" data-chart="serps">
      <h3>Organic Search (Negative % • Control %)</h3>
      <div class="chart-actions">
        <span class="dates-range muted" aria-live="polite"></span>
        <div class="dates-pager">
          <button class="dates-prev" title="Older window">←</button>
          <button class="dates-next" title="Newer window">→</button>
        </div>
      </div>
      <canvas id="serpChart"></canvas>
    </div>
  </div>

  <div class="table-card">
    <p class="table-hint">Select a sector using the checkbox to view its trend lines.</p>
    <div class="table-scroll">
      <table>
        <thead>
          <tr>
            <th style="width:56px">Select</th>
            <th data-key="sector">Sector</th>
            <th data-key="avg_daily_change">
              <div class="tooltip-header">
                Avg Overnight<br>Change % ▲▼
                <span class="tooltip-text">Average overnight gap (yesterday's close to today's open) across all sector companies. Reflects after-hours market reactions to news and events</span>
              </div>
            </th>
            <th data-key="avg_stock_change">
              <div class="tooltip-header">
                Avg 7-Day<br>Change % ▲▼
                <span class="tooltip-text">Average 7-day stock price % change for all companies in this sector. Reveals longer-term sector momentum</span>
              </div>
            </th>
            <th data-key="neg_news">
              <div class="tooltip-header">
                Negative News<br>% ▲▼
                <span class="tooltip-text">Combined negative article sentiment across all companies in this sector. Aggregates sector-wide reputational pressure</span>
              </div>
            </th>
            <th data-key="neg_serp">
              <div class="tooltip-header">
                Negative Organic % ▲▼
                <span class="tooltip-text">Combined negative organic search results across all sector companies on Google Page 1. Indicates sector-wide search perception</span>
              </div>
            </th>
            <th data-key="ctrl_pct">
              <div class="tooltip-header">
                Organic Control<br>% ▲▼
                <span class="tooltip-text">Combined organic search result control by all sector companies. Shows industry's collective narrative control over organic results</span>
              </div>
            </th>
            <th data-key="neg_serp_all">
              <div class="tooltip-header">
                Total SERP Negative<br>% ▲▼
                <span class="tooltip-text">Negative share across all SERP features plus organic results for this sector</span>
              </div>
            </th>
            <th data-key="ctrl_pct_all">
              <div class="tooltip-header">
                Total SERP Control<br>% ▲▼
                <span class="tooltip-text">Control share across all SERP features plus organic results for this sector</span>
              </div>
            </th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <div class="pagination">
      <button id="prevBtn">Prev</button>
      <div>Page <span id="pageNo">1</span> / <span id="pageTotal">1</span></div>
      <button id="nextBtn">Next</button>
    </div>
  </div>
</div>

<script>
/* ================= Config & Runtime ================= */
const COUNTS_CANDIDATES   = ['/api/v1/daily_counts?kind=brand_articles'];
const SERPS_DAILY_CSV     = '/api/v1/daily_counts?kind=brand_serps';
const ROSTER_CANDIDATES   = ['/api/v1/roster'];
const SERP_FEATURES_PATH  = () => `/api/v1/serp_features?entity=brand&days=${DATE_WINDOW_SIZE}`;
const SERP_FEATURES_CONTROL_PATH = () => `/api/v1/serp_feature_controls?entity=brand&days=${DATE_WINDOW_SIZE}`;

let allCountsRows = [];
let serpsDaily = [];
let sectorFromBrand = new Map();
let brandsBySector = new Map();
let globalStockData = {};
let serpFeatureRows = [];
let serpFeatureControlRows = [];
let featureNegByDateBrand = new Map();
let featureCtrlByDateBrand = new Map();
let crisisBrandKeys = new Set();
let fortuneFlags = new Map();
let companySizeFilter = 'all';
let crisisOnly = false;

let filteredRows = [];
let selectedSector = null;
let currentSort = { key:null, dir:1 };
let currentPage = 1;
const PAGE_SIZE = 25;

let newsChart, serpChart, featureChart, featureControlChart;

const DATE_WINDOW_SIZE = 30;
let dateWindowStart = null;
let dateWindowPinned = false;
const _loadSections = ['roster','news','serps','features','stock'];
const _loadLabels = {
  roster: 'Roster',
  news: 'News sentiment',
  serps: 'SERP metrics',
  features: 'SERP features',
  stock: 'Stock data'
};
let _loadState = {};
let _dataRendered = false;
let dataReady = false;

const FEATURE_ORDER_SENTIMENT = ['organic','aio_citations','paa_items','videos_items','perspectives_items','top_stories_items'];
const FEATURE_LABELS = {
  organic: 'Organic',
  aio_citations: 'AIO citations',
  paa_items: 'PAA',
  videos_items: 'Videos',
  perspectives_items: 'Perspectives',
  top_stories_items: 'Top stories'
};

function updateChartSkeletons(){
  const byChart = {news:'news',serps:'serps',features:'features'};
  document.querySelectorAll('.chart-card[data-chart]').forEach(card=>{
    const key = card.getAttribute('data-chart');
    const loadKey = byChart[key] || key;
    const done = _loadState[loadKey] === 'done';
    card.classList.toggle('loading', !done);
  });
}

function initLoadStatus(){
  _loadState = Object.fromEntries(_loadSections.map(k => [k, 'loading']));
  const items = document.getElementById('loadItems');
  const wrap = document.getElementById('loadStatus');
  if (wrap) wrap.style.display = 'block';
  if (items){
    items.innerHTML = _loadSections.map(k => `<span class="load-pill" data-key="${k}">${_loadLabels[k] || k}: loading</span>`).join('');
  }
  updateLoadBar();
}

function setLoadStatus(key, state){
  _loadState[key] = state;
  const pill = document.querySelector(`.load-pill[data-key="${key}"]`);
  if (pill){
    pill.textContent = `${_loadLabels[key] || key}: ${state}`;
    pill.classList.toggle('done', state === 'done');
    pill.classList.toggle('error', state === 'error');
  }
  updateLoadBar();
  updateChartSkeletons();
}

function updateLoadBar(){
  const total = _loadSections.length;
  const done = Object.values(_loadState).filter(v => v === 'done').length;
  const fill = document.getElementById('loadBarFill');
  if (fill){
    fill.style.width = `${Math.round((done / total) * 100)}%`;
  }
  maybeHideLoadStatus();
}

function maybeHideLoadStatus(){
  const total = _loadSections.length;
  const done = Object.values(_loadState).filter(v => v === 'done').length;
  const wrap = document.getElementById('loadStatus');
  if (wrap && done === total && _dataRendered){
    wrap.style.display = 'none';
  }
}

/* ================= Utilities ================= */
const isISODate = s => /^\d{4}-\d{2}-\d{2}$/.test(String(s||'').trim());
const esc = (s) => String(s ?? '').replace(/[&<>\"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":"&#39;"}[m]));
const fmtPct = v => (v==null) ? 'N/A' : (Math.round(v*100) + '%');

const canonBrand = s => String(s || '').toLowerCase().replace(/\s+/g,' ').trim();

function featureIndexKey(date, brandKey){
  return `${date}|${brandKey}`;
}

function rebuildFeatureIndexes(){
  featureNegByDateBrand = new Map();
  featureCtrlByDateBrand = new Map();
  crisisBrandKeys = new Set();

  serpFeatureRows.forEach(r => {
    if (!FEATURE_ORDER_SENTIMENT.includes(r.feature)) return;
    const brandKey = canonBrand(r.entity || '');
    if (!brandKey || !isISODate(r.date)) return;
    const key = featureIndexKey(r.date, brandKey);
    const cur = featureNegByDateBrand.get(key) || {total: 0, neg: 0};
    cur.total += r.total || 0;
    cur.neg += r.neg || 0;
    featureNegByDateBrand.set(key, cur);
    if (r.feature === 'top_stories_items' && (r.total || 0) > 0 && (r.neg || 0) > 0) {
      crisisBrandKeys.add(brandKey);
    }
  });

  serpFeatureControlRows.forEach(r => {
    if (!FEATURE_ORDER_SENTIMENT.includes(r.feature)) return;
    const brandKey = canonBrand(r.entity || '');
    if (!brandKey || !isISODate(r.date)) return;
    const key = featureIndexKey(r.date, brandKey);
    const cur = featureCtrlByDateBrand.get(key) || {total: 0, ctrl: 0};
    cur.total += r.total || 0;
    cur.ctrl += r.ctrl || 0;
    featureCtrlByDateBrand.set(key, cur);
  });
}

function matchesCompanySize(brandKey){
  const flags = fortuneFlags.get(brandKey) || {};
  if (companySizeFilter === 'fortune500') return !!flags.f500;
  if (companySizeFilter === 'fortune1000') return !!flags.f1000;
  if (companySizeFilter === 'forbes') return !!flags.forbes;
  return true;
}

/********************** Stock Data **********************/
async function loadStockData() {
  try {
    // Get today's date in UTC (matching the workflow's perspective)
    const now = new Date();
    const todayUTC = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    const today = todayUTC.toISOString().split('T')[0];
    
    let stockData = {};
    
    try {
      const rows = await fetchCsv(`/api/v1/stock_data?date=${today}`);
      stockData = parseStockRows(rows);
    } catch {
      // Try yesterday in UTC
      const yesterdayUTC = new Date(todayUTC);
      yesterdayUTC.setUTCDate(yesterdayUTC.getUTCDate() - 1);
      const yesterday = yesterdayUTC.toISOString().split('T')[0];
      
      const rows = await fetchCsv(`/api/v1/stock_data?date=${yesterday}`);
      stockData = parseStockRows(rows);
    }
    
    setLoadStatus('stock', 'done');
    return stockData;
  } catch (error) {
    console.warn('Could not load stock data:', error);
    setLoadStatus('stock', 'error');
    return {};
  }
}

function parseStockRows(rows) {
  const stockData = {};
  const toFloat = (val) => {
    if (val === null || val === undefined || val === '') return null;
    const num = parseFloat(val);
    return Number.isFinite(num) ? num : null;
  };
  rows.forEach(r => {
    const company = String(r.company || '').trim();
    if (!company) return;
    const priceHistory = Array.isArray(r.price_history)
      ? r.price_history
      : String(r.price_history || '').split('|').filter(Boolean).map(Number).filter(n => Number.isFinite(n));
    const dateHistory = Array.isArray(r.date_history)
      ? r.date_history
      : String(r.date_history || '').split('|').filter(Boolean);
    const volumeHistory = Array.isArray(r.volume_history)
      ? r.volume_history
      : String(r.volume_history || '').split('|').filter(Boolean).map(Number).filter(n => Number.isFinite(n));
    stockData[company] = {
      ticker: String(r.ticker || ''),
      company,
      openingPrice: toFloat(r.opening_price ?? r.openingPrice),
      dailyChange: toFloat(r.daily_change_pct ?? r.dailyChange ?? r.daily_change),
      sevenDayChange: toFloat(r.seven_day_change_pct ?? r.sevenDayChange),
      priceHistory,
      dateHistory,
      volumeHistory,
      lastUpdated: r.last_updated || ''
    };
  });
  return stockData;
}

function clampDateStart(total){
  if (total <= DATE_WINDOW_SIZE) return 0;
  const maxStart = total - DATE_WINDOW_SIZE;
  const start = (dateWindowStart ?? maxStart);
  return Math.min(Math.max(0, start), maxStart);
}
function sliceWindow(arr, start, size){ return arr.slice(start, start + size); }
function updateDateRangeUI(allDates){
  const start = clampDateStart(allDates.length);
  const end = Math.min(allDates.length, start + DATE_WINDOW_SIZE);
  const label = allDates.length ? `${allDates[start]} — ${allDates[end - 1]}` : '';
  document.querySelectorAll('.dates-range').forEach(el => el.textContent = label);

  const atStart = start === 0;
  const atEnd   = (start + DATE_WINDOW_SIZE) >= allDates.length;
  document.querySelectorAll('.dates-prev').forEach(b => b.disabled = atStart);
  document.querySelectorAll('.dates-next').forEach(b => b.disabled = atEnd);
}
function hookDatePager(allDates){
  const goPrev = () => {
    const total = allDates.length;
    if (total <= DATE_WINDOW_SIZE) return;
    dateWindowPinned = true;
    dateWindowStart = clampDateStart(total) - DATE_WINDOW_SIZE;
    if (dateWindowStart < 0) dateWindowStart = 0;
    renderCharts();
  };
  const goNext = () => {
    const total = allDates.length;
    if (total <= DATE_WINDOW_SIZE) return;
    const maxStart = total - DATE_WINDOW_SIZE;
    dateWindowPinned = true;
    dateWindowStart = Math.min(maxStart, clampDateStart(total) + DATE_WINDOW_SIZE);
    renderCharts();
  };
  document.querySelectorAll('.dates-prev').forEach(b => b.onclick = goPrev);
  document.querySelectorAll('.dates-next').forEach(b => b.onclick = goNext);
}

/* ================= CSV helpers ================= */
async function fetchCsv(url){
  const r = await fetch(url, {cache:'no-store'});
  if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
  const contentType = r.headers.get('content-type') || '';
  if (contentType.includes('application/json')) {
    return await r.json();
  }
  const t = await r.text();
  return await new Promise((res, rej) => {
    Papa.parse(t, {header:true, skipEmptyLines:true,
      complete: out => res(out.data || []), error: e => rej(e)
    });
  });
}
async function fetchCsvAny(candidates){
  for (const u of candidates){
    try { const rows = await fetchCsv(u); if (Array.isArray(rows)) return rows; }
    catch(e){ /* keep trying */ }
  }
  return [];
}

/* ================= Loading ================= */
async function loadCounts(){
  try{
    const rows = await fetchCsvAny(COUNTS_CANDIDATES);
    allCountsRows = rows
      .map(r => ({
        date: String(r.date || '').trim(),
        company: String(r.company || r.brand || '').trim(),
        pos: +r.positive || +r.pos || 0,
        neu: +r.neutral  || +r.neu || 0,
        neg: +r.negative || +r.neg || 0
      }))
      .filter(r => isISODate(r.date) && r.company);
    setLoadStatus('news', 'done');
  } catch (e){
    allCountsRows = [];
    setLoadStatus('news', 'error');
  }
}

async function loadSerpDaily(){
  try{
    const rows = await fetchCsv(SERPS_DAILY_CSV);
    serpsDaily = rows.map(r => ({
      date: (r.date||'').trim(),
      company: (r.company||r.brand||'').trim(),
      total: +r.total || 0,
      neg_serp: +r.negative_serp || +r.neg_serp || 0,
      ctrl: +r.controlled || +r.control || 0,
    })).filter(r => isISODate(r.date) && r.company);
    setLoadStatus('serps', 'done');
  }catch(e){
    serpsDaily = [];
    setLoadStatus('serps', 'error');
  }
}

async function loadSerpFeatures(){
  try{
    const rows = await fetchCsv(SERP_FEATURES_PATH());
    serpFeatureRows = rows.map(r => ({
      date: String(r.date || '').trim(),
      entity: String(r.entity_name || r.entity || '').trim(),
      feature: String(r.feature_type || '').trim(),
      total: +r.total_count || +r.total || 0,
      neg: +r.negative_count || +r.negative || 0
    })).filter(r => isISODate(r.date) && r.entity && r.feature);
    const ctrlRows = await fetchCsv(SERP_FEATURES_CONTROL_PATH());
    serpFeatureControlRows = ctrlRows.map(r => ({
      date: String(r.date || '').trim(),
      entity: String(r.entity_name || r.entity || '').trim(),
      feature: String(r.feature_type || '').trim(),
      total: +r.total_count || +r.total || 0,
      ctrl: +r.controlled_count || +r.controlled || 0
    })).filter(r => isISODate(r.date) && r.entity && r.feature);
    rebuildFeatureIndexes();
    setLoadStatus('features', 'done');
  } catch (e){
    serpFeatureRows = [];
    serpFeatureControlRows = [];
    featureNegByDateBrand = new Map();
    featureCtrlByDateBrand = new Map();
    setLoadStatus('features', 'error');
  }
}

async function loadRosterSectors() {
  try{
    const rows = await fetchCsvAny(ROSTER_CANDIDATES);

    sectorFromBrand.clear();
    brandsBySector.clear();
    fortuneFlags = new Map();

    rows.forEach(r => {
      const brandRaw  = r.company || r.Company || r.brand || r.Brand || '';
      const sector    = r.sector  || r.Sector  || '';
      const f500 = String(r['Fortune 500'] || r.fortune_500 || r.fortune500 || '').trim();
      const f1000 = String(r['Fortune 1000'] || r.fortune_1000 || r.fortune1000 || '').trim();
      const forbes = String(r['Forbes'] || r['Forbes 100'] || r['Forbes 2000'] || r.forbes || r.forbes_100 || r.forbes_2000 || '').trim();
      const brandKey  = canonBrand(brandRaw);
      if (!brandKey || !sector) return;

      sectorFromBrand.set(brandKey, sector);
      if (!brandsBySector.has(sector)) brandsBySector.set(sector, new Set());
      brandsBySector.get(sector).add(brandKey);
      fortuneFlags.set(brandKey, {
        f500: ['true','1','yes','y','x'].includes(f500.toLowerCase()),
        f1000: ['true','1','yes','y','x'].includes(f1000.toLowerCase()),
        forbes: ['true','1','yes','y','x'].includes(forbes.toLowerCase())
      });
    });
    populateSectorFilterOptions();
    setLoadStatus('roster', 'done');
  } catch (e){
    sectorFromBrand.clear();
    brandsBySector.clear();
    fortuneFlags = new Map();
    populateSectorFilterOptions();
    setLoadStatus('roster', 'error');
  }
}

function populateSectorFilterOptions(){
  const sel = document.getElementById('sectorFilterSelect');
  if (!sel) return;
  const prev = sel.value || '';
  const sectors = [...brandsBySector.keys()].filter(Boolean).sort((a,b)=>a.localeCompare(b));
  sel.innerHTML = `<option value="">All sectors</option>` + sectors.map(s => `<option value="${esc(s)}">${esc(s)}</option>`).join('');
  if (prev && sectors.includes(prev)) sel.value = prev;
}


/* ================= Init ================= */
async function init(){
  initLoadStatus();
  dataReady = false;
  await Promise.all([
    loadRosterSectors(),
    loadCounts(),
    loadSerpDaily(),
    loadSerpFeatures(),
    loadStockData().then(data => {
      globalStockData = data;
      if (Object.keys(globalStockData).length > 0) {
        setLoadStatus('stock', 'done');
      }
      return data;
    })
  ]);

  const dateSet = new Set([
    ...allCountsRows.map(r => r.date),
    ...serpsDaily.map(r => r.date)
  ].filter(isISODate));
  const dates = [...dateSet].sort();
  const sel = document.getElementById('dateSelect');
  sel.innerHTML = dates.map(d => `<option value="${d}">${d}</option>`).join('');
  sel.value = dates[dates.length-1] || '';
  sel.addEventListener('change', ()=>{ currentPage=1; selectedSector=null; renderAll(); });

  document.getElementById('filterInput').addEventListener('input', ()=>{ currentPage=1; renderAll(); });
  const sectorFilterSelect = document.getElementById('sectorFilterSelect');
  if (sectorFilterSelect){
    sectorFilterSelect.onchange = ()=>{ currentPage = 1; selectedSector = null; renderAll(); };
  }
  document.getElementById('refreshBtn').onclick = async ()=>{
    const statusEl = document.getElementById('refreshStatus');
    const refreshTargets = 'News, Organic SERP, SERP Features, Negative Summary';
    if (statusEl) statusEl.textContent = `Refreshing charts: ${refreshTargets}…`;
    try {
      const resp = await fetch('/api/internal/refresh_aggregates', { method: 'POST' });
      if (!resp.ok) throw new Error('refresh_failed');
      const wait = async () => {
        for (let i = 0; i < 240; i++){
          const r = await fetch('/api/internal/refresh_aggregates/status');
          if (!r.ok) throw new Error('status_failed');
          const data = await r.json();
          if (data.status !== 'in_progress') return data;
          await new Promise(res => setTimeout(res, 1000));
        }
        return { status: 'timeout' };
      };
      const result = await wait();
      if (statusEl) {
        if (result.status === 'ok') {
          statusEl.textContent = `Refreshed charts: ${refreshTargets}`;
        } else if (result.status === 'skipped') {
          statusEl.textContent = `Refresh skipped (locked): ${refreshTargets}`;
        } else if (result.status === 'timeout') {
          statusEl.textContent = `Still refreshing: ${refreshTargets}`;
        } else {
          statusEl.textContent = `Refresh failed: ${refreshTargets}`;
        }
      }
    } catch (e) {
      if (statusEl) statusEl.textContent = `Refresh failed: ${refreshTargets}`;
    }
    if (statusEl) {
      setTimeout(() => {
        statusEl.textContent = '';
      }, 3000);
    }
    await init();
  };
  document.getElementById('clearBtn').onclick = ()=>{
    selectedSector = null;
    document.getElementById('filterInput').value = '';
    const sectorFilter = document.getElementById('sectorFilterSelect');
    if (sectorFilter) sectorFilter.value = '';
    renderAll();
  };
  const companySizeSelect = document.getElementById('companySizeSelect');
  if (companySizeSelect){
    companySizeSelect.value = companySizeFilter;
    companySizeSelect.onchange = ()=>{
      companySizeFilter = companySizeSelect.value || 'all';
      renderAll();
    };
  }
  const crisisBtn = document.getElementById('crisisBtn');
  if (crisisBtn){
    crisisBtn.onclick = ()=>{
      crisisOnly = !crisisOnly;
      crisisBtn.classList.toggle('active', crisisOnly);
      renderAll();
    };
  }
  document.getElementById('prevBtn').onclick = ()=>{ if (currentPage>1){ currentPage--; renderTable(); } };
  document.getElementById('nextBtn').onclick = ()=>{ const totalPages = Math.max(1, Math.ceil(filteredRows.length / PAGE_SIZE)); if (currentPage<totalPages){ currentPage++; renderTable(); } };

  document.querySelectorAll('thead th[data-key]').forEach(th=>{
    th.style.cursor='pointer';
    th.addEventListener('click', ()=>{
      const k = th.getAttribute('data-key');
      if (currentSort.key === k) currentSort.dir *= -1; else { currentSort.key = k; currentSort.dir = 1; }
      renderTable();
    });
  });

  const ro = new ResizeObserver(() => {
    if (newsChart) newsChart.resize();
    if (serpChart) serpChart.resize();
    if (featureChart) featureChart.resize();
    if (featureControlChart) featureControlChart.resize();
  });
  document.querySelectorAll('.chart-card').forEach(el => ro.observe(el));

  dataReady = true;
  renderAll();
}

/* ================= Sector rows ================= */
async function buildSectorRowsForDate(d) {
  const newsByBrand = new Map();
  for (const r of allCountsRows) {
    if (r.date !== d) continue;
    const b = canonBrand(r.company || r.brand || r.ceo || '');
    if (!b) continue;
    const cur = newsByBrand.get(b) || {pos:0, neu:0, neg:0};
    cur.pos += +r.pos || 0;
    cur.neu += +r.neu || 0;
    cur.neg += +r.neg || 0;
    newsByBrand.set(b, cur);
  }

  const serpByBrand = new Map();
  for (const r of serpsDaily) {
    if (r.date !== d) continue;
    const b = canonBrand(r.company || r.brand || '');
    if (!b) continue;
    const cur = serpByBrand.get(b) || {total:0, neg:0, ctrl:0};
    cur.total += +r.total   || 0;
    cur.neg   += +r.neg_serp|| 0;
    cur.ctrl  += +r.ctrl    || 0;
    serpByBrand.set(b, cur);
  }

  const sectors = [];
  brandsBySector.forEach((brandSet, sectorName) => {
    let nPos=0, nNeu=0, nNeg=0, sTot=0, sNeg=0, sCtrl=0;
    let sfTot=0, sfNeg=0, sfCtrl=0;
    let dailyChanges = [];
    let sevenDayChanges = [];

    brandSet.forEach(bKey => {
      if (!matchesCompanySize(bKey)) return;
      if (crisisOnly && !crisisBrandKeys.has(bKey)) return;
      const n = newsByBrand.get(bKey);
      if (n) { nPos += n.pos; nNeu += n.neu; nNeg += n.neg; }
      const s = serpByBrand.get(bKey);
      if (s) { sTot += s.total; sNeg += s.neg; sCtrl += s.ctrl; }
      const featureKey = featureIndexKey(d, bKey);
      const sf = featureNegByDateBrand.get(featureKey);
      if (sf) {
        sfTot += sf.total;
        sfNeg += sf.neg;
      }
      const sc = featureCtrlByDateBrand.get(featureKey);
      if (sc) {
        sfCtrl += sc.ctrl;
      }
      
      // Get stock data for this brand
      for (const [company, stock] of Object.entries(globalStockData)) {
        if (canonBrand(company) === bKey) {
          if (stock.dailyChange !== null) dailyChanges.push(stock.dailyChange);
          if (stock.sevenDayChange !== null) sevenDayChanges.push(stock.sevenDayChange);
          break;
        }
      }
    });

    const newsTot = nPos + nNeu + nNeg;

    const neg_news = newsTot ? (nNeg / newsTot) : null;
    const neg_serp = sTot    ? (sNeg / sTot)    : null;
    const ctrl_pct = sTot    ? (sCtrl / sTot)   : null;
    const total_serp = (sTot + sfTot);
    const neg_serp_all = total_serp ? ((sNeg + sfNeg) / total_serp) : null;
    const ctrl_pct_all = total_serp ? ((sCtrl + sfCtrl) / total_serp) : null;
    const avg_daily_change = dailyChanges.length ? 
      (dailyChanges.reduce((a,b) => a+b, 0) / dailyChanges.length) : null;
    const avg_stock_change = sevenDayChanges.length ? 
      (sevenDayChanges.reduce((a,b) => a+b, 0) / sevenDayChanges.length) : null;

    if (newsTot || sTot || sfTot) {
      sectors.push({ sector: sectorName, neg_news, neg_serp, ctrl_pct, neg_serp_all, ctrl_pct_all, avg_daily_change, avg_stock_change });
    }
  });

  sectors.sort((a,b) => a.sector.localeCompare(b.sector));
  return sectors;
}


/* ================= Renderers ================= */
async function renderAll(){
  const d = document.getElementById('dateSelect').value;
  const filter = document.getElementById('filterInput').value.trim().toLowerCase();
  const sectorFilter = (document.getElementById('sectorFilterSelect')?.value || '').trim();

  const rows = (await buildSectorRowsForDate(d)).filter(r => {
    if (filter && !r.sector.toLowerCase().includes(filter)) return false;
    if (sectorFilter && r.sector !== sectorFilter) return false;
    return true;
  });

  filteredRows = rows;
  currentPage = 1;

  if (rows.length === 1){
    selectedSector = rows[0].sector;
  } else if (selectedSector && !rows.some(r => r.sector === selectedSector)){
    selectedSector = null;
  }

  renderTable();
  renderCharts();
  _dataRendered = true;
  maybeHideLoadStatus();
}

function renderTable(){
  const tbody = document.getElementById('tbody');
  if (!dataReady) {
    tbody.innerHTML = Array.from({length: 6}).map(() => `
      <tr class="skeleton-row">
        <td colspan="9"><div class="skeleton-bar full"></div></td>
      </tr>
    `).join('');
    return;
  }
  let rows = [...filteredRows];

  if (currentSort.key){
    rows.sort((a,b)=>{
      const ka = a[currentSort.key], kb = b[currentSort.key];
      if (typeof ka === 'string') return currentSort.dir * ka.localeCompare(kb);
      return currentSort.dir * ((ka ?? -999) - (kb ?? -999));
    });
  }

  const start = (currentPage-1)*PAGE_SIZE;
  const pageRows = rows.slice(start, start+PAGE_SIZE);

  tbody.innerHTML = pageRows.map(r=>{
    const checked = (selectedSector && selectedSector===r.sector) ? 'checked' : '';
    
    let dailyChangeHtml = '<span class="muted">N/A</span>';
    if (r.avg_daily_change !== null) {
      const changeClass = r.avg_daily_change >= 0 ? 'positive' : 'negative';
      const changeSymbol = r.avg_daily_change >= 0 ? '▲' : '▼';
      dailyChangeHtml = `<span class="stock-change ${changeClass}">${changeSymbol} ${Math.abs(r.avg_daily_change).toFixed(2)}%</span>`;
    }
    
    let sevenDayChangeHtml = '<span class="muted">N/A</span>';
    if (r.avg_stock_change !== null) {
      const changeClass = r.avg_stock_change >= 0 ? 'positive' : 'negative';
      const changeSymbol = r.avg_stock_change >= 0 ? '▲' : '▼';
      sevenDayChangeHtml = `<span class="stock-change ${changeClass}">${changeSymbol} ${Math.abs(r.avg_stock_change).toFixed(2)}%</span>`;
    }
    
    return `<tr>
      <td><input type="checkbox" class="sectorCheck" data-sector="${esc(r.sector)}" ${checked} /></td>
      <td>${esc(r.sector)}</td>
      <td>${dailyChangeHtml}</td>
      <td>${sevenDayChangeHtml}</td>
      <td>${fmtPct(r.neg_news)}</td>
      <td>${fmtPct(r.neg_serp)}</td>
      <td>${fmtPct(r.ctrl_pct)}</td>
      <td>${fmtPct(r.neg_serp_all)}</td>
      <td>${fmtPct(r.ctrl_pct_all)}</td>
    </tr>`;
  }).join('');

  tbody.querySelectorAll('.sectorCheck').forEach(cb=>{
    cb.addEventListener('change', (e)=>{
      const sec = e.target.getAttribute('data-sector');
      if (e.target.checked){
        selectedSector = sec;
        tbody.querySelectorAll('.sectorCheck').forEach(x=>{ if (x!==e.target) x.checked=false; });
      } else {
        if (selectedSector === sec) selectedSector = null;
      }
      renderCharts();
    });
  });

  document.getElementById('pageNo').textContent = String(currentPage);
  document.getElementById('pageTotal').textContent = String(Math.max(1, Math.ceil(filteredRows.length / PAGE_SIZE)));
}

function getDateSeries(){
  let allowed = null;
  if (selectedSector && brandsBySector.has(selectedSector)){
    allowed = brandsBySector.get(selectedSector);
  }

  const byDate = new Map();
  allCountsRows.forEach(r=>{
    const brandKey = canonBrand(r.company || r.brand || '');
    if (allowed && !allowed.has(brandKey)) return;
    const key = r.date;
    if (!byDate.has(key)) byDate.set(key,{pos:0,neu:0,neg:0});
    const bucket = byDate.get(key);
    bucket.pos += +r.pos||0;
    bucket.neu += +r.neu||0;
    bucket.neg += +r.neg||0;
  });

  const serpByDate = new Map();
  serpsDaily.forEach(r=>{
    const brandKey = canonBrand(r.company || r.brand || '');
    if (allowed && !allowed.has(brandKey)) return;
    const key = r.date;
    if (!serpByDate.has(key)) serpByDate.set(key,{total:0,neg:0,ctrl:0});
    const s = serpByDate.get(key);
    s.total += +r.total||0;
    s.neg   += +r.neg_serp||0;
    s.ctrl  += +r.ctrl||0;
  });

  const dates = [...new Set([...byDate.keys(), ...serpByDate.keys()])]
    .filter(isISODate)
    .sort();

  const newsPos=[], newsNeu=[], newsNeg=[], serpNegPct=[], serpCtrlPct=[];
  dates.forEach(d=>{
    const n = byDate.get(d)||{pos:0,neu:0,neg:0};
    const t = n.pos+n.neu+n.neg || 0;
    newsPos.push(t? n.pos/t*100 : 0);
    newsNeu.push(t? n.neu/t*100 : 0);
    newsNeg.push(t? n.neg/t*100 : 0);

    const s = serpByDate.get(d)||{total:0,neg:0,ctrl:0};
    serpNegPct.push(s.total? s.neg/s.total*100 : 0);
    serpCtrlPct.push(s.total? s.ctrl/s.total*100 : 0);
  });

  return {dates, newsPos, newsNeu, newsNeg, serpNegPct, serpCtrlPct};
}

function getFeatureSeries(){
  const byDate = new Map();
  const totalByDate = new Map();
  let allowed = null;
  if (selectedSector && brandsBySector.has(selectedSector)){
    allowed = brandsBySector.get(selectedSector);
  }
  const organicByDate = new Map();
  serpsDaily.forEach(r=>{
    const brandKey = canonBrand(r.company || r.brand || '');
    if (allowed && !allowed.has(brandKey)) return;
    const key = r.date;
    if (!organicByDate.has(key)) organicByDate.set(key, {total:0, neg:0});
    const o = organicByDate.get(key);
    o.total += +r.total || 0;
    o.neg += +r.neg_serp || 0;
  });
  serpFeatureRows.forEach(r=>{
    const brandKey = canonBrand(r.entity || '');
    if (allowed && !allowed.has(brandKey)) return;
    if (!FEATURE_ORDER_SENTIMENT.includes(r.feature)) return;
    if (!totalByDate.has(r.date)) totalByDate.set(r.date, 0);
    totalByDate.set(r.date, totalByDate.get(r.date) + (r.total || 0));
    if (!byDate.has(r.date)) byDate.set(r.date, {});
    const bucket = byDate.get(r.date);
    if (!bucket[r.feature]) bucket[r.feature] = {neg:0};
    bucket[r.feature].neg += r.neg || 0;
  });
  organicByDate.forEach((o, date)=>{
    if (!totalByDate.has(date)) totalByDate.set(date, 0);
    totalByDate.set(date, totalByDate.get(date) + o.total);
    if (!byDate.has(date)) byDate.set(date, {});
    const bucket = byDate.get(date);
    if (!bucket.organic) bucket.organic = {neg:0};
    bucket.organic.neg += o.neg || 0;
  });
  const dates = [...totalByDate.keys()].filter(isISODate).sort();
  const series = {};
  FEATURE_ORDER_SENTIMENT.forEach(f => { series[f] = []; });
  dates.forEach(d=>{
    const bucket = byDate.get(d) || {};
    const dayTotal = totalByDate.get(d) || 0;
    FEATURE_ORDER_SENTIMENT.forEach(f=>{
      const v = bucket[f] || {neg:0};
      series[f].push(dayTotal ? (v.neg / dayTotal * 100) : 0);
    });
  });
  return {dates, series, order: FEATURE_ORDER_SENTIMENT, countsByDate: byDate, totalsByDate: totalByDate};
}

function getFeatureControlSeries(){
  const byDate = new Map();
  const totalByDate = new Map();
  let allowed = null;
  if (selectedSector && brandsBySector.has(selectedSector)){
    allowed = brandsBySector.get(selectedSector);
  }
  const organicByDate = new Map();
  serpsDaily.forEach(r=>{
    const brandKey = canonBrand(r.company || r.brand || '');
    if (allowed && !allowed.has(brandKey)) return;
    const key = r.date;
    if (!organicByDate.has(key)) organicByDate.set(key, {total:0, ctrl:0});
    const o = organicByDate.get(key);
    o.total += +r.total || 0;
    o.ctrl += +r.ctrl || 0;
  });
  serpFeatureControlRows.forEach(r=>{
    const brandKey = canonBrand(r.entity || '');
    if (allowed && !allowed.has(brandKey)) return;
    if (!FEATURE_ORDER_SENTIMENT.includes(r.feature)) return;
    if (!byDate.has(r.date)) byDate.set(r.date, {});
    const bucket = byDate.get(r.date);
    if (!bucket[r.feature]) bucket[r.feature] = {ctrl:0};
    bucket[r.feature].ctrl += r.ctrl || 0;
    if (!totalByDate.has(r.date)) totalByDate.set(r.date, 0);
    totalByDate.set(r.date, totalByDate.get(r.date) + (r.total || 0));
  });
  organicByDate.forEach((o, date)=>{
    if (!byDate.has(date)) byDate.set(date, {});
    const bucket = byDate.get(date);
    if (!bucket.organic) bucket.organic = {ctrl:0};
    bucket.organic.ctrl += o.ctrl || 0;
    if (!totalByDate.has(date)) totalByDate.set(date, 0);
    totalByDate.set(date, totalByDate.get(date) + o.total);
  });
  const dates = [...totalByDate.keys()].filter(isISODate).sort();
  const series = {};
  FEATURE_ORDER_SENTIMENT.forEach(f => { series[f] = []; });
  dates.forEach(d=>{
    const bucket = byDate.get(d) || {};
    const dayTotal = totalByDate.get(d) || 0;
    FEATURE_ORDER_SENTIMENT.forEach(f=>{
      const v = bucket[f] || {ctrl:0};
      series[f].push(dayTotal ? (v.ctrl / dayTotal * 100) : 0);
    });
  });
  return {dates, series, order: FEATURE_ORDER_SENTIMENT, countsByDate: byDate, totalsByDate: totalByDate};
}

function renderCharts(){
  const {dates, newsPos, newsNeu, newsNeg, serpNegPct, serpCtrlPct} = getDateSeries();
  const {dates: featureDates, series: featureSeries, order: featureOrder, countsByDate: featureCountsByDate} = getFeatureSeries();
  const {dates: featureCtrlDates, series: featureCtrlSeries, order: featureCtrlOrder, countsByDate: featureCtrlCountsByDate} = getFeatureControlSeries();

  const maxStart = Math.max(0, dates.length - DATE_WINDOW_SIZE);
  if (!dateWindowPinned || dateWindowStart === null){
    dateWindowStart = maxStart;
  }
  const start = clampDateStart(dates.length);
  const d  = sliceWindow(dates,       start, DATE_WINDOW_SIZE);
  const nP = sliceWindow(newsPos,     start, DATE_WINDOW_SIZE);
  const nN = sliceWindow(newsNeu,     start, DATE_WINDOW_SIZE);
  const nG = sliceWindow(newsNeg,     start, DATE_WINDOW_SIZE);
  const sN = sliceWindow(serpNegPct,  start, DATE_WINDOW_SIZE);
  const sC = sliceWindow(serpCtrlPct, start, DATE_WINDOW_SIZE);
  const featureIndex = new Map(featureDates.map((d,i)=>[d,i]));
  const fDates = d;
  const featureData = featureOrder.map(f=>{
    const arr = featureSeries[f] || [];
    return fDates.map(dt=>{
      const idx = featureIndex.get(dt);
      return idx == null ? 0 : (arr[idx] || 0);
    });
  });
  const featureCtrlIndex = new Map(featureCtrlDates.map((d,i)=>[d,i]));
  const fcDates = d;
  const featureCtrlData = featureCtrlOrder.map(f=>{
    const arr = featureCtrlSeries[f] || [];
    return fcDates.map(dt=>{
      const idx = featureCtrlIndex.get(dt);
      return idx == null ? 0 : (arr[idx] || 0);
    });
  });

  updateDateRangeUI(dates);
  hookDatePager(dates);

  const who = selectedSector ? selectedSector : "Index Average";
  const fmtPctInt = v => `${Math.round(v)}%`;

  const commonOpts = {
    responsive: true,
    maintainAspectRatio: false,
    layout: { padding: { bottom: 24 } },
    scales: {
      x: { ticks: { color: '#ebf2f2' }, grid: { color: 'rgba(255,255,255,.05)' } },
      y: {
        ticks: { color: '#ebf2f2', stepSize: 20, callback: (v) => fmtPctInt(v) },
        grid: { color: 'rgba(255,255,255,.06)' },
        suggestedMin: 0, suggestedMax: 100
      }
    },
    plugins: {
      legend: { labels: { color: '#ebf2f2' } },
      title: { display: true, text: who, color: '#ebf2f2',
        font: { weight: 'bold', size: 14 }, padding: { top: 10, bottom: 6 } },
      tooltip: { callbacks: { label: (ctx) => {
        const label = ctx.dataset?.label ? `${ctx.dataset.label}: ` : '';
        const val = (ctx.parsed && typeof ctx.parsed.y === 'number') ? ctx.parsed.y : (typeof ctx.parsed === 'number' ? ctx.parsed : 0);
        return `${label}${fmtPctInt(val)}`;
      }}}
    }
  };

  const nh = document.getElementById('newsChart').getContext('2d');
  if (newsChart) newsChart.destroy();
  newsChart = new Chart(nh, {
    type: 'bar',
    data: {
      labels: d,
      datasets: [
        { label: 'Positive %', data: nP, backgroundColor: '#82c618', stack: 's' },
        { label: 'Neutral %',  data: nN, backgroundColor: '#cfdbdd', stack: 's' },
        { label: 'Negative %', data: nG, backgroundColor: '#ff8261', stack: 's' }
      ]
    },
    options: { ...commonOpts }
  });

  const sh = document.getElementById('serpChart').getContext('2d');
  if (serpChart) serpChart.destroy();
  serpChart = new Chart(sh, {
    type: 'line',
    data: {
      labels: d,
      datasets: [
        { label: 'Negative SERP %', data: sN, tension: .25, borderColor: '#ff8261', backgroundColor: 'rgba(255,130,97,.2)', fill: false },
        { label: 'Control %',       data: sC, tension: .25, borderColor: '#58dbed', backgroundColor: 'rgba(88,219,237,.15)', fill: false }
      ]
    },
    options: { ...commonOpts }
  });

  const fh = document.getElementById('featureChart').getContext('2d');
  if (featureChart) featureChart.destroy();
  featureChart = new Chart(fh, {
    type: 'line',
    data: {
      labels: fDates,
      datasets: featureOrder.map((feature, idx) => ({
        label: FEATURE_LABELS[feature] || feature,
        data: featureData[idx],
        tension: .25,
        borderColor: ['#ff3b30', '#ff5e57', '#ff7a59', '#ff9f43', '#ff6f91', '#e63946'][idx % 6],
        backgroundColor: ['rgba(255,59,48,.35)','rgba(255,94,87,.35)','rgba(255,122,89,.35)','rgba(255,159,67,.35)','rgba(255,111,145,.35)','rgba(230,57,70,.35)'][idx % 6],
        fill: true,
        stack: 'features'
      }))
    },
    options: {
      ...commonOpts,
      plugins: {
        ...commonOpts.plugins,
        title: { ...commonOpts.plugins.title, text: `${who} • SERP Feature Negative Share` },
        tooltip: { callbacks: { label: (ctx) => {
          const label = ctx.dataset?.label ? `${ctx.dataset.label}: ` : '';
          const val = (ctx.parsed && typeof ctx.parsed.y === 'number') ? ctx.parsed.y : (typeof ctx.parsed === 'number' ? ctx.parsed : 0);
          const date = ctx.label;
          const feature = featureOrder[ctx.datasetIndex];
          const bucket = featureCountsByDate.get(date) || {};
          const count = bucket[feature]?.neg || 0;
          return `${label}${fmtPctInt(val)} (${count})`;
        }}}
      }
    }
  });

  const fch = document.getElementById('featureControlChart').getContext('2d');
  if (featureControlChart) featureControlChart.destroy();
  featureControlChart = new Chart(fch, {
    type: 'line',
    data: {
      labels: fcDates,
      datasets: featureCtrlOrder.map((feature, idx) => ({
        label: FEATURE_LABELS[feature] || feature,
        data: featureCtrlData[idx],
        tension: .25,
        borderColor: ['#2d9cdb', '#1b84d1', '#1769aa', '#115293', '#0d3b66', '#0a2742'][idx % 6],
        backgroundColor: ['rgba(45,156,219,.35)','rgba(27,132,209,.35)','rgba(23,105,170,.35)','rgba(17,82,147,.35)','rgba(13,59,102,.35)','rgba(10,39,66,.35)'][idx % 6],
        fill: true,
        stack: 'features'
      }))
    },
    options: {
      ...commonOpts,
      plugins: {
        ...commonOpts.plugins,
        title: { ...commonOpts.plugins.title, text: `${who} • SERP Feature Control Share` },
        tooltip: { callbacks: { label: (ctx) => {
          const label = ctx.dataset?.label ? `${ctx.dataset.label}: ` : '';
          const val = (ctx.parsed && typeof ctx.parsed.y === 'number') ? ctx.parsed.y : (typeof ctx.parsed === 'number' ? ctx.parsed : 0);
          const date = ctx.label;
          const feature = featureCtrlOrder[ctx.datasetIndex];
          const bucket = featureCtrlCountsByDate.get(date) || {};
          const count = bucket[feature]?.ctrl || 0;
          return `${label}${fmtPctInt(val)} (${count})`;
        }}}
      }
    }
  });
}

/* ================= Go ================= */
init();
</script>
</body>
</html>
