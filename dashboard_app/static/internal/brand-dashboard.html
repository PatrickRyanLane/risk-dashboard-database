<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<title>Brand Risk Dashboard</title>

<!-- Chart.js + PapaParse + Annotation Plugin CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
// DATA CONFIGURATION - Uses Cloud Run proxy for authenticated access
// The proxy endpoints in app.py fetch from private GCS bucket
function getDataUrl(path) {
  // Route to appropriate proxy endpoint based on path
  if (path.startsWith('data/')) {
    // /api/data/daily_counts/..., /api/data/processed_articles/..., etc.
    return '/api/data/' + path.substring(5);
  } else if (path.startsWith('rosters/')) {
    // /api/data/rosters/main-roster.csv
    return '/api/data/' + path;
  }
  return '/api/data/' + path;
}
</script>

<style>
:root{
  --bg:#044152; --card:#092e37; --muted:#a2ebf3; --text:#ebf2f2; --accent:#58dbed; --black:#1f2121;
  --pill-neg:#ff8261; --pill-neu:#cfdbdd; --pill-pos:#82c618;
  --stroke:#0e2230; --chip:#12343e; --chipBorder:#174550;
  --stock-pos:#82c616; --stock-neg:#ff8261;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
.wrap{max-width:1200px;margin:0 auto;padding:20px}
h1{font-size:28px;margin:6px 0 18px}

/* Controls */
.controls{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end;margin:0 0 16px}
.controls select,
.controls input,
.controls button{height:32px;padding:6px 10px;font-size:12px;line-height:1.2;border-radius:8px}
.controls input{min-width:220px}
.filter-toggle.active{border-color:#58dbed;box-shadow:0 0 0 1px rgba(88,219,237,.35);color:#58dbed}
.controls .spacer{flex:0 0 12px}
.filter-block{display:flex;flex-wrap:wrap;align-items:flex-end;gap:8px;flex:1 1 420px}
.filter-block .muted{flex:1 1 100%}
.card{background:var(--card);border:1px solid var(--stroke);border-radius:12px;padding:12px}
select,input[type="text"]{background:var(--black);border:1px solid #23314d;border-radius:10px;color:var(--text);padding:8px 10px}
button{background:var(--black);border:1px solid #2a3b5e;color:var(--text);border-radius:10px;padding:8px 12px;cursor:pointer}
button:hover{filter:brightness(1.08)}

/* Charts grid ‚Äì equal heights, responsive */
.grid{
  display:grid;
  grid-auto-rows:minmax(340px,40vh);
  gap:16px;
  margin:16px 0;
}

/* Chart cards */
.chart-card{background:var(--card);border:1px solid var(--stroke);border-radius:12px;padding:12px 12px 48px;position:relative}
.chart-card canvas{width:100% !important;height:100% !important;display:block}
.chart-card.loading::after{content:"";position:absolute;left:12px;right:12px;top:54px;bottom:16px;border-radius:10px;background:linear-gradient(90deg,rgba(255,255,255,.05),rgba(255,255,255,.18),rgba(255,255,255,.05));background-size:200% 100%;animation:skeleton 1.2s ease-in-out infinite;pointer-events:none}
.chart-card.loading canvas{opacity:.2}

/* Chart pagination controls (top-right) */
.chart-actions{
  position:absolute;
  top:10px; right:12px;
  display:flex; align-items:center; gap:10px;
}
.chart-actions .dates-range{ font-size:12px; }
.chart-actions .dates-pager{ display:flex; gap:6px; }
.chart-actions .dates-pager button{
  background:#1f2121; border:1px solid #2a3b5e; color:var(--text);
  border-radius:8px; padding:4px 8px; cursor:pointer;
}
.chart-actions .dates-pager button[disabled]{ opacity:.45; cursor:not-allowed; }

/* Table */
.table-card{background:var(--card);border:1px solid var(--stroke);border-radius:12px;padding:10px}
.table-hint{margin:0 0 8px;color:var(--muted)}
.load-status{margin-top:10px;width:100%;display:flex;flex-direction:column;align-items:center}
.load-bar{height:6px;background:rgba(255,255,255,.08);border-radius:999px;overflow:hidden}
.load-bar-fill{height:100%;width:0%;background:var(--accent);transition:width .2s ease}
.load-items{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;font-size:12px;color:var(--muted);justify-content:center;text-align:center}
.load-pill{padding:2px 8px;border-radius:999px;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.1)}
.load-pill.done{color:#82c618;border-color:rgba(130,198,24,.35);background:rgba(130,198,24,.1)}
.load-pill.error{color:#ff8261;border-color:rgba(255,130,97,.35);background:rgba(255,130,97,.1)}
.table-scroll{overflow-x:auto;-webkit-overflow-scrolling:touch}
.table-scroll::-webkit-scrollbar{height:8px}
.table-scroll::-webkit-scrollbar-track{background:rgba(255,255,255,.05);border-radius:8px}
.table-scroll::-webkit-scrollbar-thumb{background:rgba(255,255,255,.12);border-radius:8px}

table{width:100%;border-collapse:separate;border-spacing:0 6px;table-layout:auto}
thead th{font-size:11px;color:var(--muted);text-align:center;padding:6px 6px;vertical-align:middle;line-height:1.2;white-space:nowrap}
thead th:first-child{white-space:normal;min-width:140px}
tbody td{padding:8px 6px;background:var(--black);border-top:1px solid #0f1831;border-bottom:1px solid #0f1831;text-align:center;white-space:nowrap}
tbody td:first-child{text-align:left;white-space:normal}
tbody tr{transition:background-color 0.15s}
tbody tr:hover{background:rgba(88,219,237,.08)}
tbody tr td:first-child{border-left:1px solid #0f1831;border-radius:10px 0 0 10px}
tbody tr td:last-child{border-right:1px solid #0f1831;border-radius:0 10px 10px 0}
.skeleton-row td{padding:10px 12px}
.skeleton-bar{height:12px;border-radius:8px;background:linear-gradient(90deg,rgba(255,255,255,.05),rgba(255,255,255,.2),rgba(255,255,255,.05));background-size:200% 100%;animation:skeleton 1.2s ease-in-out infinite}
.skeleton-bar.full{width:100%;height:16px}
.skeleton-bar.wide{width:90%}
.skeleton-bar.med{width:60%}
.skeleton-bar.narrow{width:35%}
@keyframes skeleton{0%{background-position:200% 0}100%{background-position:-200% 0}}

/* Brand column styling with flexbox */
.brand-cell-content{display:flex;align-items:center;gap:8px}
.brand-name{font-weight:500}

/* Stock styling */
.stock-price{font-family:'Courier New',monospace;font-weight:500;color:var(--text)}
.stock-change{font-weight:600}
.stock-change.positive{color:var(--stock-pos)}
.stock-change.negative{color:var(--stock-neg)}

/* Sparkline */
.sparkline-cell{text-align:center;padding:6px 8px !important;cursor:pointer}
.sparkline-cell:hover{background:rgba(88,219,237,.15)}
.sparkline{display:inline-block;vertical-align:middle}

.pill{font-size:12px;border-radius:999px;padding:3px 8px;border:1px solid var(--chipBorder);background:var(--chip);color:#cfe0ff}
.pill.low{background:rgba(130,198,24,.15);color:#82c618}
.pill.med{background:rgba(207,219,221,.25);color:#cfdbdd}
.pill.high{background:rgba(255,130,97,.15);color:#ff8261}
.link{color:var(--accent);text-decoration:underline}

@media (max-width:960px){
  .table-card{padding:8px}
  .table-hint{font-size:12px}
  thead th,tbody td{padding:6px 4px}
  .pill{font-size:11px}
}

/* Tooltips */
.tooltip-header {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted #a2ebf3;
  cursor: help;
}

.tooltip-header .tooltip-text {
  visibility: hidden;
  width: 240px;
  background-color: #1f2121;
  color: #ebf2f2;
  text-align: left;
  border: 1px solid #2a3b5e;
  border-radius: 8px;
  padding: 10px 12px;
  position: absolute;
  z-index: 1000;
  top: 125%;
  left: 50%;
  margin-left: -120px;
  opacity: 0;
  transition: opacity 0.3s ease;
  font-size: 12px;
  line-height: 1.5;
  font-weight: normal;
  white-space: normal;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
}

.tooltip-header .tooltip-text::after {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #1f2121 transparent;
}

.tooltip-header:hover .tooltip-text {
  visibility: visible;
  opacity: 1;
}

@media (max-width: 768px) {
  .tooltip-header .tooltip-text {
    width: 200px;
    margin-left: -100px;
    font-size: 11px;
  }
}

/* Sticky first column (Company + checkbox) */
thead th:first-child, tbody td:first-child{
  position:sticky;left:0;z-index:2;box-shadow:2px 0 0 0 rgba(255,255,255,.06);
  background:var(--card);
}
tbody td:first-child{background:var(--black)}

/* Pagination */
.pagination{display:flex;gap:8px;align-items:center;justify-content:flex-end;margin-top:8px}

/* Modal (z-index > sticky) */
.modal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;padding:24px;z-index:10000}
.modal.open{display:flex}
.modal .box{max-width:900px;width:100%;max-height:85vh;overflow:auto;background:#0e152a;border:1px solid #1b2745;border-radius:16px;position:relative;z-index:10001}
.modal header{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid #12203d}
.modal header h3{margin:0;font-size:16px}
.modal .content{padding:16px}
.close{color:#aaa;float:right;font-size:28px;font-weight:bold;cursor:pointer;line-height:20px}
.close:hover,.close:focus{color:var(--text)}
.badges{display:flex;gap:8px;margin-top:8px}
.badge{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid transparent}
.badge.positive{background:rgba(130,198,24,.15);color:#82c618;border-color:rgba(130,198,24,.35)}
.badge.neutral{background:rgba(207,219,221,.25);color:#cfdbdd;border-color:rgba(207,219,221,.45)}
.badge.negative{background:rgba(255,130,97,.15);color:#ff8261;border-color:rgba(255,130,97,.35)}
.edit-controls{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
.edit-controls select{
  appearance:none;
  background:var(--chip);
  border:1px solid var(--chipBorder);
  color:#cfe0ff;
  border-radius:999px;
  padding:5px 16px;
  font-size:12px;
  cursor:pointer;
  text-align:center;
}
.edit-controls select:focus{outline:2px solid rgba(88,219,237,.35)}
.edit-controls select.sentiment-positive{background:rgba(130,198,24,.15);color:#82c618;border-color:rgba(130,198,24,.35)}
.edit-controls select.sentiment-neutral{background:rgba(207,219,221,.25);color:#cfdbdd;border-color:rgba(207,219,221,.45)}
.edit-controls select.sentiment-negative{background:rgba(255,130,97,.15);color:#ff8261;border-color:rgba(255,130,97,.35)}
.edit-controls select.controlled{background:rgba(88,219,237,.15);color:#58dbed;border-color:rgba(88,219,237,.35)}
.edit-controls select.uncontrolled{background:rgba(255,130,97,.15);color:#ff8261;border-color:rgba(255,130,97,.35)}
.edit-status{font-size:12px;color:var(--muted)}
.badge.controlled{background:rgba(88,219,237,.15);color:#58dbed;border-color:rgba(88,219,237,.35)}
.badge.uncontrolled{background:rgba(255,130,97,.15);color:#ff8261;border-color:rgba(255,130,97,.35)}
.serp-flags{margin-top:6px;font-size:12px;opacity:.8;letter-spacing:.2px}
.edit-flags{display:inline-flex;gap:10px;align-items:center;font-size:12px;opacity:.85;white-space:nowrap}
.muted{color:var(--muted)}
.serp-feature-viz{display:flex;gap:16px;flex-wrap:nowrap;align-items:stretch;margin:40px 0}
@media (max-width: 900px){
  .serp-feature-viz{flex-wrap:wrap}
}
.toggle-switch{display:inline-flex;align-items:center;gap:8px;cursor:pointer}
.toggle-switch input{display:none}
.toggle-slider{position:relative;width:36px;height:20px;background:#1f2b4a;border:1px solid #2b3d63;border-radius:999px;transition:all .2s ease}
.toggle-slider::after{content:'';position:absolute;top:2px;left:2px;width:14px;height:14px;background:#8aa0b6;border-radius:50%;transition:transform .2s ease, background .2s ease}
.toggle-switch input:checked + .toggle-slider{background:rgba(88,219,237,.2);border-color:rgba(88,219,237,.5)}
.toggle-switch input:checked + .toggle-slider::after{transform:translateX(16px);background:#58dbed}
.toggle-text{font-size:12px;color:#cfdbdd}

/* Stock chart modal */
#stockChartModal .box{max-width:1000px}
#stockChart{width:100%;height:400px}

/* SERP cards */
.serp-cards{display:grid;gap:12px;margin-top:12px}
.serp-card{background:var(--card);border:1px solid var(--stroke);border-radius:12px;padding:14px 16px;position:relative}
.serp-feature-flag{
  position:absolute;
  top:10px;
  right:12px;
  font-size:11px;
  text-transform:uppercase;
  letter-spacing:.3px;
  padding:3px 8px;
  border-radius:999px;
  background:rgba(88,219,237,.12);
  border:1px solid rgba(88,219,237,.35);
  color:#58dbed;
}
.serp-domain{font-size:12px;color:var(--muted);margin-bottom:4px}
.serp-title a{color:var(--text);text-decoration:underline}
.serp-snippet{color:var(--muted);margin-top:6px;line-height:1.35}
.serp-metrics{margin:4px 0 0;color:var(--muted)}
.serp-metrics b{color:var(--text)}

/* ===== UPDATED: RESPONSIVE NEGATIVE ARTICLES HEATMAP STYLES ===== */

/* Enhanced stock chart modal with responsive sizing */
#stockChartModal .box {
  max-width: 1000px;
  width: 95%;
  max-height: 90vh;
  overflow: auto;
}

/* Responsive chart sizing */
#stockChart {
  width: 100% !important;
  height: 450px !important;
  min-height: 400px;
}

/* Stock modal header - responsive font sizing */
#stockChartModal header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 14px 18px;
  border-bottom: 1px solid #12203d;
  gap: 12px;
}

#stockChartModal header h3 {
  margin: 0;
  font-size: 16px;
  line-height: 1.3;
  flex: 1;
  padding-right: 12px;
}

/* Volume toggle button */
.volume-toggle {
  background: rgba(88, 219, 237, 0.15);
  border: 1px solid rgba(88, 219, 237, 0.3);
  color: var(--accent);
  border-radius: 8px;
  padding: 6px 12px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
  font-weight: 500;
}

.volume-toggle:hover {
  background: rgba(88, 219, 237, 0.25);
  border-color: rgba(88, 219, 237, 0.5);
  transform: translateY(-1px);
}

.volume-toggle.active {
  background: var(--accent);
  color: var(--black);
  border-color: var(--accent);
}

.volume-toggle.active:hover {
  background: #6de5f5;
  border-color: #6de5f5;
}

/* Trends toggle button */
.trends-toggle {
  background: rgba(168, 85, 247, 0.15);
  border: 1px solid rgba(168, 85, 247, 0.3);
  color: #a855f7;
  border-radius: 8px;
  padding: 6px 12px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
  font-weight: 500;
}

.trends-toggle:hover {
  background: rgba(168, 85, 247, 0.25);
  border-color: rgba(168, 85, 247, 0.5);
  transform: translateY(-1px);
}

.trends-toggle.active {
  background: #a855f7;
  color: white;
  border-color: #a855f7;
}

.trends-toggle.active:hover {
  background: #b975f7;
  border-color: #b975f7;
}
.fav-toggle{background:#1f2121;border:1px solid #2a3b5e;color:var(--text);border-radius:8px;padding:6px 10px;cursor:pointer;font-size:12px;display:inline-flex;gap:6px;align-items:center}
.controls button#refreshBtn,
.controls button#clearBtn,
.controls button#fullHistoryBtn{font-size:12px;padding:6px 10px;min-height:30px}
.fav-toggle.active{background:rgba(255,215,0,.18);border-color:rgba(255,215,0,.5);color:#ffd54f}
.fav-star{color:#ffd54f;font-weight:700;margin-right:6px}
.fav-inline{background:transparent;border:0;color:#666;cursor:pointer;font-size:14px;line-height:1;padding:0 4px}
.fav-inline.active{color:#ffd54f}


#stockChartModal .content {
  padding: 18px;
}

/* Sparkline hover effect - make it more obvious it's clickable */
.sparkline-cell {
  cursor: pointer;
  transition: background-color 0.2s ease;
  position: relative;
}

.sparkline-cell:hover {
  background: rgba(88, 219, 237, 0.2) !important;
}

.sparkline-cell::after {
  content: '';
  position: absolute;
  inset: 0;
  border: 2px solid transparent;
  border-radius: 8px;
  pointer-events: none;
  transition: border-color 0.2s ease;
}

.sparkline-cell:hover::after {
  border-color: rgba(88, 219, 237, 0.4);
}

.sparkline-cell:hover .sparkline {
  filter: brightness(1.2);
}

/* Loading state for stock chart */
.stock-chart-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 400px;
  color: var(--muted);
  font-size: 14px;
}

.stock-chart-loading::before {
  content: 'üìä';
  font-size: 32px;
  margin-right: 12px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.5; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

/* Add subtle animation when chart loads */
@keyframes chartFadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

#stockChart {
  animation: chartFadeIn 0.3s ease-out;
}

/* Enhanced close button for stock modal */
#stockChartModal .close {
  transition: all 0.2s ease;
  cursor: pointer;
  user-select: none;
  font-size: 32px;
  line-height: 28px;
  font-weight: 300;
  padding: 0 4px;
  margin: -4px 0;
}

#stockChartModal .close:hover {
  color: var(--accent) !important;
  transform: scale(1.15);
}

#stockChartModal .close:active {
  transform: scale(0.95);
}

/* Better visual feedback for the sparkline */
.sparkline {
  transition: opacity 0.2s ease;
}

.sparkline-cell:active .sparkline {
  opacity: 0.7;
}

/* ===== TABLET RESPONSIVENESS (768px - 1024px) ===== */
@media (max-width: 1024px) {
  #stockChartModal .box {
    width: 92%;
    max-width: 900px;
  }
  
  #stockChart {
    height: 420px !important;
    min-height: 380px;
  }
  
  #stockChartModal header h3 {
    font-size: 15px;
  }
  
  #stockChartModal .content {
    padding: 16px;
  }
}

/* ===== MOBILE RESPONSIVENESS (< 768px) ===== */
@media (max-width: 768px) {
  /* Full-screen modal on mobile */
  #stockChartModal .box {
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100vh;
    margin: 0;
    border-radius: 0;
    display: flex;
    flex-direction: column;
  }
  
  #stockChartModal header {
    padding: 12px 16px;
    flex-shrink: 0;
  }
  
  #stockChartModal header h3 {
    font-size: 14px;
    line-height: 1.4;
  }
  
  #stockChartModal .close {
    font-size: 28px;
    line-height: 24px;
  }
  
  /* Scrollable content area */
  #stockChartModal .content {
    padding: 12px 16px 16px;
    overflow-y: auto;
    flex: 1;
    -webkit-overflow-scrolling: touch;
  }
  
  /* Optimized chart height for mobile */
  #stockChart {
    height: 350px !important;
    min-height: 300px;
    max-height: 60vh;
  }
  
  /* Touch-friendly close button */
  #stockChartModal .close {
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

/* ===== SMALL MOBILE (< 480px) ===== */
@media (max-width: 480px) {
  #stockChartModal header h3 {
    font-size: 13px;
  }
  
  #stockChart {
    height: 320px !important;
    min-height: 280px;
  }
  
  #stockChartModal .content {
    padding: 10px 12px 14px;
  }
}

/* ===== LANDSCAPE MOBILE ===== */
@media (max-width: 768px) and (orientation: landscape) {
  #stockChart {
    height: 70vh !important;
    min-height: 250px;
  }
}

/* ===== LARGE SCREENS (> 1400px) ===== */
@media (min-width: 1400px) {
  #stockChartModal .box {
    max-width: 1200px;
  }
  
  #stockChart {
    height: 500px !important;
  }
  
  #stockChartModal header h3 {
    font-size: 18px;
  }
}

/* Prevent body scroll when modal is open on mobile */
body:has(#stockChartModal.open) {
  overflow: hidden;
}

/* Better touch targets for mobile */
@media (max-width: 768px) {
  .sparkline-cell {
    padding: 10px 8px !important;
  }
  
  button {
    min-height: 44px;
    padding: 10px 14px;
  }
}

/* Optional: Add a subtle overlay background blur on larger screens */
@media (min-width: 769px) {
  #stockChartModal {
    backdrop-filter: blur(2px);
    -webkit-backdrop-filter: blur(2px);
  }
}

/* ===== ENHANCED HEATMAP LEGEND STYLES ===== */
.heatmap-legend {
  display: flex;
  gap: 18px;
  align-items: center;
  justify-content: center;
  padding: 10px 16px;
  background: rgba(30, 40, 55, 0.7);
  border: 1px solid rgba(88, 219, 237, 0.2);
  border-radius: 8px;
  margin-top: 14px;
  font-size: 13px;
  font-weight: 500;
  flex-wrap: wrap;
  color: #e3f2f7;
}

.heatmap-legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.heatmap-legend-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 2px solid #fff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  flex-shrink: 0;
}

.heatmap-legend-dot.medium {
  background: #ffaa44;
}

.heatmap-legend-dot.high {
  background: #ff4444;
}

@media (max-width: 768px) {
  .heatmap-legend {
    font-size: 12px;
    gap: 14px;
    padding: 8px 12px;
  }
  
  .heatmap-legend-dot {
    width: 10px;
    height: 10px;
  }
}


</style>
</head>

<body>
<div class="wrap">
  <h1>Brand Risk Dashboard</h1>

  <div class="controls card">
    <div>
      <div class="muted" style="font-size:12px;margin:0 0 4px">Date</div>
      <select id="dateSelect"></select>
    </div>
    <div class="filter-block">
      <div class="muted" style="font-size:12px;margin:0 0 4px">Filter (Company)</div>
      <input id="filterInput" type="text" placeholder="Type to filter‚Ä¶" />
      <button id="clearBtn">Clear Selection</button>
    </div>
    <button id="favoritesBtn" class="fav-toggle" title="Show favorites only">‚òÖ Favorites</button>
    <button id="fortune500Btn" class="filter-toggle" title="Filter to Fortune 500">Fortune 500</button>
    <button id="fortune1000Btn" class="filter-toggle" title="Filter to Fortune 1000">Fortune 1000</button>
    <!-- <button id="fullHistoryBtn">Load 180 days</button> -->
    <div class="spacer"></div>
    <button id="refreshBtn">Refresh Data</button>
    <span id="refreshStatus" class="muted" style="font-size:12px;align-self:center"></span>
    <div class="load-status" id="loadStatus">
      <div class="load-bar"><div class="load-bar-fill" id="loadBarFill"></div></div>
      <div class="load-items" id="loadItems"></div>
    </div>
  </div>

  <div class="grid">
    <div class="chart-card loading" data-chart="features">
      <h3>SERP Feature Negativity (stacked)</h3>
      <div class="chart-actions">
        <span class="dates-range muted" aria-live="polite"></span>
        <div class="dates-pager">
          <button class="dates-prev" title="Older window">‚Üê</button>
          <button class="dates-next" title="Newer window">‚Üí</button>
        </div>
      </div>
      <canvas id="featureChart"></canvas>
    </div>

    <div class="chart-card loading" data-chart="features">
      <h3>SERP Feature Control (stacked)</h3>
      <div class="chart-actions">
        <span class="dates-range muted" aria-live="polite"></span>
        <div class="dates-pager">
          <button class="dates-prev" title="Older window">‚Üê</button>
          <button class="dates-next" title="Newer window">‚Üí</button>
        </div>
      </div>
      <canvas id="featureControlChart"></canvas>
    </div>

    <div class="chart-card loading" data-chart="news">
      <h3>News sentiment (percent of articles)</h3>
      <div class="chart-actions">
        <span class="dates-range muted" aria-live="polite"></span>
        <div class="dates-pager">
          <button class="dates-prev" title="Older window">‚Üê</button>
          <button class="dates-next" title="Newer window">‚Üí</button>
        </div>
      </div>
      <canvas id="newsChart"></canvas>
    </div>

    <div class="chart-card loading" data-chart="serps">
      <h3>Organic Search (Negative % ‚Ä¢ Control %)</h3>
      <div class="chart-actions">
        <span class="dates-range muted" aria-live="polite"></span>
        <div class="dates-pager">
          <button class="dates-prev" title="Older window">‚Üê</button>
          <button class="dates-next" title="Newer window">‚Üí</button>
        </div>
      </div>
      <canvas id="serpChart"></canvas>
    </div>
  </div>

  <div class="table-card">
    <p class="table-hint">Select a company using the checkbox to view its trend lines. Click the sparkline to see 30-day stock chart with negative article markers.</p>
    <div class="table-scroll">
      <table>
        <thead>
          <tr>
            <th>Company</th>
            <th data-key="stock_price">
              <div class="tooltip-header">
                Stock Price
                <span class="tooltip-text">Current stock price from today's market open (or latest available)</span>
              </div>
            </th>
            <th data-key="daily_change">
              <div class="tooltip-header">
                Overnight<br>Change % ‚ñ≤‚ñº
                <span class="tooltip-text">Percentage change from yesterday's close to today's market open (overnight gap)</span>
              </div>
            </th>
            <th data-key="trend">
              <div class="tooltip-header">
                30-Day Trend
                <span class="tooltip-text">Visual sparkline of stock price over 30 days. Click to view detailed chart with negative news articles overlaid as markers</span>
              </div>
            </th>
            <th data-key="neg_news">
              <div class="tooltip-header">
                Negative<br>News % ‚ñ≤‚ñº
                <span class="tooltip-text">Percentage of articles mentioning this company that have negative sentiment. Higher = greater negative coverage</span>
              </div>
            </th>
            <th data-key="neg_top_stories">
              <div class="tooltip-header">
                Negative<br>Top Stories % ‚ñ≤‚ñº
                <span class="tooltip-text">Percentage of Top Stories results with negative sentiment for this company on the selected day</span>
              </div>
            </th>
            <th data-key="neg_serp">
              <div class="tooltip-header">
                Negative<br>SERP % ‚ñ≤‚ñº
                <span class="tooltip-text">Percentage of results on Google's first page with negative sentiment about this company. Indicates public perception visibility</span>
              </div>
            </th>
            <th data-key="ctrl_pct">
              <div class="tooltip-header">
                SERP<br>Control % ‚ñ≤‚ñº
                <span class="tooltip-text">Percentage of Page 1 Google results owned/controlled by the company (official site, press releases, social). Higher = better reputation management</span>
              </div>
            </th>
            <th data-key="risk">
              <div class="tooltip-header">
                Risk<br>‚ñ≤‚ñº
                <span class="tooltip-text">Composite risk score based on Negative SERP % and Control %. High risk = significant negative search visibility with limited control. Low risk = minimal negative presence or strong narrative control.</span>
              </div>
            </th>
            <th>Headlines</th>
            <th>SERP</th>
            <th>SERP<br>Features</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <div class="pagination">
      <button id="prevBtn">Prev</button>
      <div>Page <span id="pageNo">1</span> / <span id="pageTotal">1</span></div>
      <button id="nextBtn">Next</button>
    </div>
  </div>
</div>

<!-- Modal -->
<div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <div class="box">
    <header>
      <h3 id="modalTitle">Title</h3>
      <button id="modalClose">Close</button>
    </header>
    <div class="content" id="modalContent"></div>
  </div>
</div>

<!-- Stock Chart Modal with Heatmap Legend -->
<div id="stockChartModal" class="modal" role="dialog" aria-modal="true">
  <div class="box">
    <header>
      <h3 id="stockChartTitle">Stock Price History</h3>
      <button id="volumeToggle" class="volume-toggle">üìä Volume</button>
      <button id="trendsToggle" class="trends-toggle">üîç Trends</button>
      <span class="close" onclick="closeStockChart()">&times;</span>
    </header>
    <div class="content">
      <canvas id="stockChart"></canvas>
      <div id="heatmapLegend" class="heatmap-legend" style="display: none;">
        <div class="heatmap-legend-item">
          <div class="heatmap-legend-dot medium"></div>
          <span>3-5 Negative Articles</span>
        </div>
        <div class="heatmap-legend-item">
          <div class="heatmap-legend-dot high"></div>
          <span>6+ Negative Articles</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/********************** Config (brand) **********************/
const DEFAULT_DAYS = 30;
const FULL_DAYS = 180;
let currentDays = DEFAULT_DAYS;
const COUNTS_PATH = () => `/api/v1/daily_counts?kind=brand_articles&days=${currentDays}`;
const SERPS_DAILY_CSV = () => `/api/v1/daily_counts?kind=brand_serps&days=${currentDays}`;
const SERP_FEATURES_INDEX_PATH  = () => `/api/v1/serp_features?entity=brand&days=${currentDays}&mode=index`;
const SERP_FEATURES_TOP_STORIES_PATH = (date) => `/api/v1/serp_features?entity=brand&days=${currentDays}&feature_type=top_stories_items${date ? `&date=${date}` : ''}`;
const SERP_FEATURES_ENTITY_PATH = name => `/api/v1/serp_features?entity=brand&days=${currentDays}&entity_name=${encodeURIComponent(name)}`;
const SERP_FEATURES_CONTROL_INDEX_PATH  = () => `/api/v1/serp_feature_controls?entity=brand&days=${currentDays}&mode=index`;
const SERP_FEATURES_CONTROL_ENTITY_PATH = name => `/api/v1/serp_feature_controls?entity=brand&days=${currentDays}&entity_name=${encodeURIComponent(name)}`;
const NEGATIVE_SUMMARY_PATH = '/api/v1/negative_summary?days=30';
const PRELOAD_MODAL_DATA = false;
const MODAL_LIMIT = 200;
const ARTICLES_DAILY_PATH = d => `/api/v1/processed_articles?date=${d}&entity=brand&kind=table`;
const HEADLINES_PATH      = (d, company, offset = 0) =>
  `/api/v1/processed_articles?date=${d}&entity=brand&kind=modal&entity_name=${encodeURIComponent(company)}&limit=${MODAL_LIMIT}&offset=${offset}`;
const SERP_PROCESSED_PATH = d => `/api/v1/processed_serps?date=${d}&entity=brand&kind=table`;
const SERP_ROWS_PATH      = (d, company, offset = 0) =>
  `/api/v1/processed_serps?date=${d}&entity=brand&kind=modal&entity_name=${encodeURIComponent(company)}&limit=${MODAL_LIMIT}&offset=${offset}`;
const SERP_FEATURE_ITEMS_PATH = (d, company, feature, offset = 0, limit = FEATURE_MODAL_LIMIT) => {
  const featParam = feature ? `&feature_type=${encodeURIComponent(feature)}` : '';
  return `/api/v1/serp_feature_items?date=${d}&entity=brand&entity_name=${encodeURIComponent(company)}${featParam}&limit=${limit}&offset=${offset}`;
};
const SERP_FEATURE_SERIES_PATH = (company, feature, days = 30) =>
  `/api/v1/serp_feature_series?entity=brand&entity_name=${encodeURIComponent(company)}&feature_type=${encodeURIComponent(feature)}&days=${days}`;

/********************** Runtime **********************/
let allCountsRows = [];
let serpsDaily    = [];
let serpFeatureIndexRows = [];
let serpFeatureEntityRows = [];
let serpFeatureControlIndexRows = [];
let serpFeatureControlEntityRows = [];
let topStoriesNegByDate = new Map();
let filteredRows  = [];
let selectedCompany = null;
let currentSort = { key:null, dir:1 };
let currentPage = 1;
let dataReady = false;
let favoritesOnly = false;
let favoriteCompanies = new Set();
const PAGE_SIZE = 25;

function updateChartSkeletons(){
  const map = {
    news: _loadState.news,
    serps: _loadState.serps,
    features: _loadState.features
  };
  document.querySelectorAll('.chart-card[data-chart]').forEach(card=>{
    const key = card.getAttribute('data-chart');
    const state = map[key];
    card.classList.toggle('loading', state !== 'done');
  });
}

function updateDateOptions(){
  const dateSet = new Set([ ...allCountsRows.map(r=>r.date), ...serpsDaily.map(r=>r.date) ].filter(isISODate));
  if (!dateSet.size) return;
  const dates = [...dateSet].sort();
  const sel = document.getElementById('dateSelect');
  const prev = sel.value;
  sel.innerHTML = dates.map(d=>`<option value="${d}">${d}</option>`).join('');
  sel.value = dates.includes(prev) ? prev : (dates[dates.length-1] || '');
  const fullHistoryBtn = document.getElementById('fullHistoryBtn');
  if (fullHistoryBtn) fullHistoryBtn.disabled = currentDays >= FULL_DAYS;
}

function maybeRenderAll(){
  const sel = document.getElementById('dateSelect');
  if (_loadState.news !== 'done' || _loadState.serps !== 'done') return;
  if (!sel.value) return;
  if (!dataReady) {
    dataReady = true;
  }
  updateChartSkeletons();
  renderAll();
}

function updateEntityUrlParam(param, value){
  try{
    const url = new URL(window.location.href);
    if (value) url.searchParams.set(param, value);
    else url.searchParams.delete(param);
    url.searchParams.delete('ceo');
    const next = `${url.pathname}${url.search}${url.hash}`;
    const current = `${window.location.pathname}${window.location.search}${window.location.hash}`;
    if (current !== next) {
      window.history.replaceState({}, '', next);
      const after = `${window.location.pathname}${window.location.search}${window.location.hash}`;
      if (after !== next) {
        window.history.pushState({}, '', next);
      }
    }
    if (window.top && window.top !== window) {
      const topUrl = new URL(window.top.location.href);
      topUrl.searchParams.set('tab', 'brands');
      if (value) topUrl.searchParams.set(param, value);
      else topUrl.searchParams.delete(param);
      topUrl.searchParams.delete('ceo');
      const topNext = `${topUrl.pathname}${topUrl.search}${topUrl.hash}`;
      window.top.history.replaceState({}, '', topNext);
    }
    console.log('üîó URL updated', param, value, next);
  }catch{}
}

async function updateFavorite(entityType, name, favorite, company=''){
  try{
    const r = await fetch('/api/internal/favorites', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({entity_type: entityType, name, favorite, company})
    });
    return r.ok;
  }catch(e){
    return false;
  }
}

async function selectCompany(name){
  if (!name) return;
  selectedCompany = name;
  updateEntityUrlParam('company', selectedCompany);
  await loadSerpFeaturesForEntity(selectedCompany);
  renderTable();
  renderCharts();
}

function isTrue(val){
  return ['true','1','yes','y'].includes(String(val || '').trim().toLowerCase());
}

async function loadRosterFavorites(){
  try{
    const rows = await fetchCsv('/api/v1/roster');
    favoriteCompanies = new Set();
    companyTickers = new Map();
    fortuneFlags = new Map();
    rows.forEach(r=>{
      const company = String(r.company || r.Company || '').trim();
      if (!company) return;
      const fav = isTrue(r.company_favorite || r['Company Favorite'] || r.favorite || r.Favorite);
      if (fav) favoriteCompanies.add(company);
      const ticker = String(r.ticker || r.Ticker || r.stock_ticker || r['Stock Ticker'] || '').trim();
      if (ticker) companyTickers.set(company, ticker);
      const f500 = String(r['Fortune 500'] || r.fortune_500 || r.fortune500 || '').trim();
      const f1000 = String(r['Fortune 1000'] || r.fortune_1000 || r.fortune1000 || '').trim();
      fortuneFlags.set(company, {
        f500: isTrue(f500) || f500.toLowerCase() === 'x',
        f1000: isTrue(f1000) || f1000.toLowerCase() === 'x'
      });
    });
  }catch(e){
    favoriteCompanies = new Set();
    companyTickers = new Map();
    fortuneFlags = new Map();
  }
}

let newsChart, serpChart, stockChart, featureChart, featureControlChart;
let globalStockData = {};
let showVolume = false; // Toggle state for volume display
let showTrends = false; // Toggle state for trends display
let globalTrendsData = {}; // Trends data by company
let companyTickers = new Map();
let fortuneFlags = new Map();
let fortuneFilter = null;

const _articlesCache = new Map();
const _serpAggCache  = new Map();
const _modalHeadlinesCache = new Map();
const _modalSerpCache = new Map();
const _serpFeatureItemsCache = new Map();
const _loadSections = ['news','serps','features','stock','trends','negative'];
const FEATURE_ORDER_SENTIMENT = ['organic','aio_citations','paa_items','videos_items','perspectives_items','top_stories_items'];
const FEATURE_ORDER_BASE = ['organic','aio','paa','videos','perspectives','top_stories'];
const FEATURE_ITEM_MAP = {
  aio: 'aio_citations',
  paa: 'paa_items',
  videos: 'videos_items',
  perspectives: 'perspectives_items',
  top_stories: 'top_stories_items'
};
const FEATURE_LABELS = {
  all: 'All Features',
  organic: 'Organic',
  aio_citations: 'AIO citations',
  paa_items: 'PAA',
  videos_items: 'Videos',
  perspectives_items: 'Perspectives',
  aio: 'AI Overview',
  paa: 'People also ask',
  videos: 'Videos',
  perspectives: 'Perspectives',
  top_stories_items: 'Top stories',
  top_stories: 'Top stories'
};
const FEATURE_ALL_KEY = 'all';
const FEATURE_MODAL_ORDER = ['aio_citations','paa_items','videos_items','perspectives_items','top_stories_items'];
const FEATURE_MODAL_LIMIT = 100;
const FEATURE_MODAL_DAYS = 30;
const FEATURE_COLORS = ['#ff3b30', '#ff5e57', '#ff7a59', '#ff9f43', '#ff6f91', '#e63946'];
const CONTROL_COLORS = ['#2d9cdb', '#1b84d1', '#1769aa', '#115293', '#0d3b66', '#0a2742'];
const mapFeatureType = (feature) => FEATURE_ITEM_MAP[feature] || feature;
const isItemFeature = (feature) => {
  const mapped = mapFeatureType(feature);
  return mapped === feature && FEATURE_ORDER_SENTIMENT.includes(mapped);
};
const _loadLabels = {
  news: 'News sentiment',
  serps: 'SERP metrics',
  features: 'SERP features',
  stock: 'Stock data',
  trends: 'Trends data',
  negative: 'Negative summary'
};
let _loadState = {};
let _dataRendered = false;
const _serpFeatureCache = new Map();
const _serpFeatureControlCache = new Map();

function initLoadStatus(){
  _loadState = Object.fromEntries(_loadSections.map(k => [k, 'loading']));
  const items = document.getElementById('loadItems');
  const wrap = document.getElementById('loadStatus');
  if (wrap) wrap.style.display = 'block';
  if (items){
    items.innerHTML = _loadSections.map(k => `<span class="load-pill" data-key="${k}">${_loadLabels[k] || k}: loading</span>`).join('');
  }
  updateLoadBar();
}

function setLoadStatus(key, state){
  _loadState[key] = state;
  const pill = document.querySelector(`.load-pill[data-key="${key}"]`);
  if (pill){
    pill.textContent = `${_loadLabels[key] || key}: ${state}`;
    pill.classList.toggle('done', state === 'done');
    pill.classList.toggle('error', state === 'error');
  }
  updateLoadBar();
  updateChartSkeletons();
}

function updateLoadBar(){
  const total = _loadSections.length;
  const done = Object.values(_loadState).filter(v => v === 'done').length;
  const fill = document.getElementById('loadBarFill');
  if (fill){
    fill.style.width = `${Math.round((done / total) * 100)}%`;
  }
  maybeHideLoadStatus();
}

function maybeHideLoadStatus(){
  const total = _loadSections.length;
  const done = Object.values(_loadState).filter(v => v === 'done').length;
  const wrap = document.getElementById('loadStatus');
  if (wrap && done === total && _dataRendered){
    wrap.style.display = 'none';
  }
}

const DATE_WINDOW_SIZE = 30;
let dateWindowStart = null;
let dateWindowPinned = false;

/********************** Utils **********************/
const isISODate = s => /^\d{4}-\d{2}-\d{2}$/.test(String(s||'').trim());
const esc = (s) => String(s ?? '').replace(/[&<>\"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m]));
const fmtPct = (v) => (v==null) ? 'N/A' : Math.round(v*100)+'%';

const NEG_COLOR   = '#ff8261';
const CTRL_COLOR  = '#58dbed';
const SOLID_WIDTH = 3;
const DASH_WIDTH  = 2;
const DASH_PATTERN = [8, 6];

/********************** Stock Data **********************/
async function loadStockData() {
  try {
    const now = new Date();
    const todayUTC = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    
    console.log('üìä Looking for most recent stock data...');
    
    // Try up to 7 days back to find the most recent stock data file
    // This handles weekends and holidays
    for (let daysBack = 0; daysBack < 7; daysBack++) {
      const checkDate = new Date(todayUTC);
      checkDate.setUTCDate(checkDate.getUTCDate() - daysBack);
      const dateStr = checkDate.toISOString().split('T')[0];
      
      try {
        const url = `/api/v1/stock_data?date=${dateStr}`;
        console.log(`üîç Trying: ${url}`);

        const rows = await fetchCsv(url);
        const stockData = parseStockRows(rows);
        
        console.log(`‚úÖ Successfully loaded stock data from ${dateStr} (${daysBack} day(s) old)`);
        console.log(`üìà Found data for ${Object.keys(stockData).length} companies`);
        
        return stockData;
      } catch (error) {
        console.log(`‚ö†Ô∏è  ${dateStr}: ${error.message}`);
        // Continue to next day
      }
    }
    
    // If we get here, no stock data was found in the last 7 days
    console.error('‚ùå No stock data found in the last 7 days');
    setLoadStatus('stock', 'error');
    return {};
    
  } catch (error) {
    console.error('‚ùå STOCK DATA LOAD FAILED:', error);
    setLoadStatus('stock', 'error');
    return {};
  }
}

function parseStockRows(rows) {
  const stockData = {};
  const toFloat = (val) => {
    if (val === null || val === undefined || val === '') return null;
    const num = parseFloat(val);
    return Number.isFinite(num) ? num : null;
  };
  rows.forEach(r => {
    const company = String(r.company || '').trim();
    if (!company) return;
    const priceHistory = Array.isArray(r.price_history)
      ? r.price_history
      : String(r.price_history || '').split('|').filter(Boolean).map(Number).filter(n => Number.isFinite(n));
    const dateHistory = Array.isArray(r.date_history)
      ? r.date_history
      : String(r.date_history || '').split('|').filter(Boolean);
    const volumeHistory = Array.isArray(r.volume_history)
      ? r.volume_history
      : String(r.volume_history || '').split('|').filter(Boolean).map(Number).filter(n => Number.isFinite(n));
    stockData[company] = {
      ticker: String(r.ticker || ''),
      company,
      openingPrice: toFloat(r.opening_price ?? r.openingPrice),
      dailyChange: toFloat(r.daily_change_pct ?? r.dailyChange ?? r.daily_change),
      sevenDayChange: toFloat(r.seven_day_change_pct ?? r.sevenDayChange),
      priceHistory,
      dateHistory,
      volumeHistory,
      lastUpdated: r.last_updated || ''
    };
  });
  return stockData;
}

function createSparkline(prices, isPositive) {
  if (!prices || prices.length < 2) return null;

  const canvas = document.createElement('canvas');
  canvas.width = 80;
  canvas.height = 24;
  canvas.className = 'sparkline';

  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  const padding = 2;

  const min = Math.min(...prices);
  const max = Math.max(...prices);
  const range = max - min || 1;

  const stepX = (width - padding * 2) / (prices.length - 1);

  ctx.beginPath();
  ctx.strokeStyle = isPositive ? '#82c616' : '#ff8261';
  ctx.lineWidth = 1.5;

  prices.forEach((price, i) => {
    const x = padding + i * stepX;
    const y = height - padding - ((price - min) / range) * (height - padding * 2);

    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  });

  ctx.stroke();

  return canvas;
}

/********************** NEGATIVE ARTICLES HEATMAP INTEGRATION **********************/

// Cache for per-company negative summaries
const negativeSummaryCache = new Map();
let negativeSummaryIndex = null;

// Threshold: minimum number of negative articles required to show a marker
const NEGATIVE_ARTICLE_THRESHOLD = 3;

async function loadNegativeSummaryIndex() {
  const logLabel = 'negative-summary';
  console.time(logLabel);
  console.log('üì∞ Loading negative articles summary...');
  setLoadStatus('negative', 'loading');
  
  try {
    const rows = await fetchCsv(`${NEGATIVE_SUMMARY_PATH}&mode=index`);
    console.log(`üìä Negative summary rows: ${rows.length}`);
    
    console.log(`üìä Loaded ${rows.length} total rows from summary file`);
    
    negativeSummaryIndex = rows;
    console.log(`‚úÖ Loaded negative summary index rows: ${rows.length}`);
    console.timeEnd(logLabel);
    setLoadStatus('negative', 'done');
    return rows;
    
  } catch (e) {
    console.error('‚ùå Failed to load negative summary:', e);
    console.timeEnd(logLabel);
    setLoadStatus('negative', 'error');
    return [];
  }
}

async function loadNegativeSummaryForCompany(company) {
  if (!company) return [];
  if (negativeSummaryCache.has(company)) return negativeSummaryCache.get(company);
  try {
    const url = `${NEGATIVE_SUMMARY_PATH}&company=${encodeURIComponent(company)}`;
    const rows = await fetchCsv(url);
    const items = [];
    rows.forEach(r => {
      const count = parseInt(r.negative_count) || 0;
      if (count < NEGATIVE_ARTICLE_THRESHOLD) return;
      items.push({
        date: String(r.date || '').trim(),
        count: count,
        headlines: (r.top_headlines || '').split('|').filter(h => h.trim()),
        type: String(r.article_type || '').trim()
      });
    });
    negativeSummaryCache.set(company, items);
    return items;
  } catch (e) {
    return [];
  }
}

/**
 * Enhanced stock chart with negative article heatmap markers, responsive design, improved legend
 */

// Load Google Trends data
async function loadTrendsData() {
  try {
    const now = new Date();
    const todayUTC = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    
    console.log('üîç Looking for most recent trends data...');
    
    for (let daysBack = 0; daysBack < 7; daysBack++) {
      const checkDate = new Date(todayUTC);
      checkDate.setUTCDate(checkDate.getUTCDate() - daysBack);
      const dateStr = checkDate.toISOString().split('T')[0];
      
      try {
        const url = `/api/v1/trends_data?date=${dateStr}`;
        console.log(`üîç Trying: ${url}`);

        const rows = await fetchCsv(url);
        const trendsData = parseTrendsRows(rows);
        
        console.log(`‚úÖ Successfully loaded trends data from ${dateStr} (${daysBack} day(s) old)`);
        console.log(`üìà Found trends for ${Object.keys(trendsData).length} companies`);
        setLoadStatus('trends', 'done');
        return trendsData;
      } catch (error) {
        console.log(`‚ö†Ô∏è  ${dateStr}: ${error.message}`);
      }
    }
    
    console.warn('‚ö†Ô∏è  No trends data found in the last 7 days');
    setLoadStatus('trends', 'error');
    return {};
    
  } catch (error) {
    console.error('‚ùå TRENDS DATA LOAD FAILED:', error);
    setLoadStatus('trends', 'error');
    return {};
  }
}

function parseTrendsRows(rows) {
  const trendsData = {};
  rows.forEach(r => {
    const company = String(r.company || '').trim();
    if (!company) return;
    const trendsHistory = Array.isArray(r.trends_history)
      ? r.trends_history
      : String(r.trends_history || '').split('|').filter(Boolean).map(Number).filter(n => Number.isFinite(n));
    const dateHistory = Array.isArray(r.date_history)
      ? r.date_history
      : String(r.date_history || '').split('|').filter(Boolean);
    trendsData[company] = {
      company,
      trendsHistory,
      dateHistory,
      lastUpdated: r.last_updated || ''
    };
  });
  return trendsData;
}

async function showStockChart(company) {
  const stock = globalStockData[company];
  if (!stock || !stock.priceHistory || !stock.priceHistory.length) {
    alert('No stock data available for this company');
    return;
  }
  
  const modal = document.getElementById('stockChartModal');
  document.getElementById('stockChartTitle').textContent = 
    `${company} (${stock.ticker}) - 30-Day Price History`;
  modal.classList.add('open');
  
  if (stockChart) stockChart.destroy();
  
  const negativeDates = await loadNegativeSummaryForCompany(company);
  const relevantNegatives = negativeDates.filter(item => 
    stock.dateHistory.includes(item.date)
  );
  
  const negativesByDate = new Map();
  relevantNegatives.forEach(item => {
    if (!negativesByDate.has(item.date)) {
      negativesByDate.set(item.date, {
        totalCount: 0,
        ceoCount: 0,
        brandCount: 0,
        allHeadlines: []
      });
    }
    const agg = negativesByDate.get(item.date);
    agg.totalCount += item.count;
    if (item.type === 'ceo') agg.ceoCount += item.count;
    if (item.type === 'brand') agg.brandCount += item.count;
    agg.allHeadlines.push(...item.headlines);
  });
  
  console.log(`üìä ${company}: ${negativesByDate.size} dates with ${NEGATIVE_ARTICLE_THRESHOLD}+ negative articles`);
  
  const legendEl = document.getElementById('heatmapLegend');
  if (negativesByDate.size > 0) {
    legendEl.style.display = 'flex';
  } else {
    legendEl.style.display = 'none';
  }
  
  const annotations = {};
  Array.from(negativesByDate.entries()).forEach(([date, data], idx) => {
    const priceIndex = stock.dateHistory.indexOf(date);
    if (priceIndex === -1) return;
    
    const price = stock.priceHistory[priceIndex];
    const intensity = data.totalCount >= 6 ? 'high' : 'medium';
    
    annotations[`negArticle${idx}`] = {
      type: 'point',
      xValue: date,
      yValue: price,
      yScaleID: 'yPrice',
      backgroundColor: intensity === 'high' ? '#ff4444' : '#ffaa44',
      borderColor: '#ffffff',
      borderWidth: 2,
      radius: Math.min(data.totalCount + 3, 14),
      enter(context) {
        context.element.options.radius = Math.min(data.totalCount + 5, 18);
        context.element.options.borderWidth = 3;
        stockChart.update('none');
        return true;
      },
      leave(context) {
        context.element.options.radius = Math.min(data.totalCount + 3, 14);
        context.element.options.borderWidth = 2;
        stockChart.update('none');
        return true;
      }
    };
  });
  
  const ctx = document.getElementById('stockChart').getContext('2d');
  // Match sparkline logic: compare first to last price in 30-day window
  const firstPrice = stock.priceHistory[0];
  const lastPrice = stock.priceHistory[stock.priceHistory.length - 1];
  const isPositive = lastPrice >= firstPrice;  
  
  const datasets = [{
    label: 'Closing Price ($)',
    data: stock.priceHistory,
    borderColor: isPositive ? '#82c616' : '#ff8261',
    backgroundColor: isPositive ? 'rgba(130, 198, 22, 0.1)' : 'rgba(255, 130, 97, 0.1)',
    borderWidth: 2,
    tension: 0.1,
    fill: true,
    pointRadius: 2,
    pointHoverRadius: 5,
    yAxisID: 'yPrice',
    type: 'line',
    order: 1
  }];
  
  if (showVolume && stock.volumeHistory && stock.volumeHistory.length > 0) {
    datasets.push({
      label: 'Volume',
      data: stock.volumeHistory,
      backgroundColor: 'rgba(88, 219, 237, 0.3)',
      borderColor: 'rgba(88, 219, 237, 0.5)',
      borderWidth: 1,
      yAxisID: 'yVolume',
      type: 'bar',
      order: 2,
      barPercentage: 0.9,
      categoryPercentage: 0.95
    });
  }
  
  const trendsData = globalTrendsData[company];
  if (showTrends && trendsData && trendsData.trendsHistory && trendsData.trendsHistory.length > 0) {
    datasets.push({
      label: 'Search Interest',
      data: trendsData.trendsHistory,
      borderColor: '#a855f7',
      backgroundColor: 'rgba(168, 85, 247, 0.1)',
      borderWidth: 2,
      tension: 0.3,
      fill: false,
      yAxisID: 'yTrends',
      type: 'line',
      order: 0,
      pointRadius: 3,
      pointHoverRadius: 5,
      pointBackgroundColor: '#a855f7',
      pointBorderColor: '#ffffff',
      pointBorderWidth: 1
    });
  }
  
  stockChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: stock.dateHistory,
      datasets: datasets
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'index',
        intersect: false
      },
      plugins: {
        legend: { 
          display: false,
          position: 'top',
          labels: {
            color: '#ffffff',
            font: {
              size: window.innerWidth < 768 ? 11 : 13,
              weight: '500'
            },
            padding: 12,
            usePointStyle: true,
            pointStyle: 'circle',
            boxWidth: 8,
            boxHeight: 8,
            generateLabels: function(chart) {
              const labels = [
                {
                  text: 'Stock Price',
                  fillStyle: isPositive ? '#82c616' : '#ff8261',
                  strokeStyle: isPositive ? '#82c616' : '#ff8261',
                  lineWidth: 2,
                  pointStyle: 'line'
                }
              ];
              
              if (showVolume && stock.volumeHistory && stock.volumeHistory.length > 0) {
                labels.push({
                  text: 'Trading Volume',
                  fillStyle: 'rgba(88, 219, 237, 0.3)',
                  strokeStyle: 'rgba(88, 219, 237, 0.5)',
                  lineWidth: 1,
                  pointStyle: 'rect'
                });
              }
              
              if (showTrends && trendsData && trendsData.trendsHistory && trendsData.trendsHistory.length > 0) {
                labels.push({
                  text: 'Search Interest (0-100)',
                  fillStyle: 'rgba(168, 85, 247, 0.1)',
                  strokeStyle: '#a855f7',
                  lineWidth: 2,
                  pointStyle: 'line'
                });
              }
              
              if (negativesByDate.size > 0) {
                let totalCeo = 0, totalBrand = 0;
                negativesByDate.forEach(data => {
                  totalCeo += data.ceoCount;
                  totalBrand += data.brandCount;
                });
                
                if (totalCeo > 0 && totalBrand > 0) {
                  labels.push({
                    text: `Negative Articles (${totalCeo} CEO, ${totalBrand} Brand)`,
                    fillStyle: '#ffaa44',
                    strokeStyle: '#ffffff',
                    lineWidth: 2,
                    pointStyle: 'circle'
                  });
                } else if (totalCeo > 0) {
                  labels.push({
                    text: `Negative CEO Articles (${totalCeo})`,
                    fillStyle: '#ffaa44',
                    strokeStyle: '#ffffff',
                    lineWidth: 2,
                    pointStyle: 'circle'
                  });
                } else if (totalBrand > 0) {
                  labels.push({
                    text: `Negative Brand Articles (${totalBrand})`,
                    fillStyle: '#ffaa44',
                    strokeStyle: '#ffffff',
                    lineWidth: 2,
                    pointStyle: 'circle'
                  });
                }
              }
              
              return labels;
            }
          }
        },
        annotation: {
          annotations: annotations
        },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.9)',
          titleColor: '#fff',
          bodyColor: '#fff',
          borderColor: 'rgba(255, 255, 255, 0.3)',
          borderWidth: 1,
          padding: window.innerWidth < 768 ? 10 : 14,
          displayColors: false,
          titleFont: {
            size: window.innerWidth < 768 ? 12 : 13,
            weight: 'bold'
          },
          bodyFont: {
            size: window.innerWidth < 768 ? 11 : 12
          },
          callbacks: {
            title: function(tooltipItems) {
              if (!tooltipItems || tooltipItems.length === 0) return '';
              return tooltipItems[0].label;
            },
            label: function(context) {
              const lines = [];
              
              if (context.dataset.yAxisID === 'yVolume') {
                const vol = context.parsed.y;
                const volStr = vol >= 1000000 
                  ? `${(vol / 1000000).toFixed(2)}M` 
                  : vol >= 1000 
                    ? `${(vol / 1000).toFixed(2)}K` 
                    : vol.toFixed(0);
                return [`Volume: ${volStr}`];
              }
              
              if (context.dataset.yAxisID === 'yTrends') {
                return [`Search Interest: ${context.parsed.y.toFixed(0)}/100`];
              }
              
              lines.push(`Price: $${context.parsed.y.toFixed(2)}`);
              
              const date = context.label;
              const negData = negativesByDate.get(date);
              
              if (negData) {
                lines.push('');
                lines.push(`‚ö†Ô∏è  ${negData.totalCount} Negative Article${negData.totalCount > 1 ? 's' : ''}`);
                
                if (negData.ceoCount > 0) {
                  lines.push(`   CEO: ${negData.ceoCount}`);
                }
                if (negData.brandCount > 0) {
                  lines.push(`   Brand: ${negData.brandCount}`);
                }
                
                const previewHeadlines = negData.allHeadlines.slice(0, 3);
                if (previewHeadlines.length > 0) {
                  lines.push('');
                  previewHeadlines.forEach((headline, i) => {
                    const maxLength = window.innerWidth < 768 ? 40 : 55;
                    const truncated = headline.length > maxLength 
                      ? headline.substring(0, maxLength - 3) + '...' 
                      : headline;
                    lines.push(`‚Ä¢ ${truncated}`);
                  });
                  
                  if (negData.allHeadlines.length > 3) {
                    lines.push(`   ... and ${negData.allHeadlines.length - 3} more`);
                  }
                }
              }
              
              return lines;
            }
          }
        }
      },
      scales: {
        yPrice: {
          type: 'linear',
          position: 'left',
          beginAtZero: false,
          ticks: {
            color: '#ebf2f2',
            font: {
              size: window.innerWidth < 768 ? 10 : 11
            },
            callback: function(value) {
              return '$' + value.toFixed(2);
            }
          },
          grid: {
            color: 'rgba(255,255,255,.08)'
          }
        },
        yVolume: {
          type: 'linear',
          position: 'right',
          display: showVolume && stock.volumeHistory && stock.volumeHistory.length > 0,
          beginAtZero: true,
          ticks: {
            color: 'rgba(88, 219, 237, 0.8)',
            font: {
              size: window.innerWidth < 768 ? 9 : 10
            },
            callback: function(value) {
              if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
              if (value >= 1000) return (value / 1000).toFixed(1) + 'K';
              return value.toFixed(0);
            }
          },
          grid: {
            display: false
          }
        },
        yTrends: {
          type: 'linear',
          position: 'right',
          display: showTrends && trendsData && trendsData.trendsHistory && trendsData.trendsHistory.length > 0,
          beginAtZero: true,
          max: 100,
          ticks: {
            color: 'rgba(168, 85, 247, 0.8)',
            font: {
              size: window.innerWidth < 768 ? 9 : 10
            },
            callback: function(value) {
              return value.toFixed(0);
            }
          },
          grid: {
            display: false
          },
          offset: showVolume
        },
        x: {
          ticks: {
            color: '#ebf2f2',
            font: {
              size: window.innerWidth < 768 ? 9 : 11
            },
            maxTicksLimit: window.innerWidth < 768 ? 6 : 10,
            autoSkip: true
          },
          grid: {
            color: 'rgba(255,255,255,.05)'
          }
        }
      }
    }
  });
  
  const volumeBtn = document.getElementById('volumeToggle');
  if (volumeBtn) {
    if (showVolume) {
      volumeBtn.classList.add('active');
    } else {
      volumeBtn.classList.remove('active');
    }
    
    if (!stock.volumeHistory || stock.volumeHistory.length === 0) {
      volumeBtn.style.display = 'none';
    } else {
      volumeBtn.style.display = 'block';
    }
    
    const newBtn = volumeBtn.cloneNode(true);
    volumeBtn.parentNode.replaceChild(newBtn, volumeBtn);
    
    newBtn.onclick = () => {
      showVolume = !showVolume;
      showStockChart(company);
    };
  }
  
  const trendsBtn = document.getElementById('trendsToggle');
  if (trendsBtn) {
    if (showTrends) {
      trendsBtn.classList.add('active');
    } else {
      trendsBtn.classList.remove('active');
    }
    
    const trendsData = globalTrendsData[company];
    if (!trendsData || !trendsData.trendsHistory || trendsData.trendsHistory.length === 0) {
      trendsBtn.style.display = 'none';
    } else {
      trendsBtn.style.display = 'block';
    }
    
    const newTrendsBtn = trendsBtn.cloneNode(true);
    trendsBtn.parentNode.replaceChild(newTrendsBtn, trendsBtn);
    
    newTrendsBtn.onclick = () => {
      showTrends = !showTrends;
      showStockChart(company);
    };
  }
}


/**
 * Close the stock chart modal
 */
function closeStockChart() {
  document.getElementById('stockChartModal').classList.remove('open');
}

/* ===== Pager helpers ===== */
function clampDateStart(total){
  if (total <= DATE_WINDOW_SIZE) return 0;
  const maxStart = total - DATE_WINDOW_SIZE;
  const start = (dateWindowStart ?? maxStart);
  return Math.min(Math.max(0, start), maxStart);
}
function sliceWindow(arr, start, size){ return arr.slice(start, start + size); }
function updateDateRangeUI(allDates){
  const start = clampDateStart(allDates.length);
  const end = Math.min(allDates.length, start + DATE_WINDOW_SIZE);
  const label = allDates.length ? `${allDates[start]} ‚Äî ${allDates[end - 1]}` : '';
  document.querySelectorAll('.dates-range').forEach(el => el.textContent = label);

  const atStart = start === 0;
  const atEnd   = (start + DATE_WINDOW_SIZE) >= allDates.length;
  document.querySelectorAll('.dates-prev').forEach(b => b.disabled = atStart);
  document.querySelectorAll('.dates-next').forEach(b => b.disabled = atEnd);
}
function hookDatePager(allDates){
  const goPrev = () => {
    const total = allDates.length;
    if (total <= DATE_WINDOW_SIZE) return;
    dateWindowPinned = true;
    dateWindowStart = clampDateStart(total) - DATE_WINDOW_SIZE;
    if (dateWindowStart < 0) dateWindowStart = 0;
    renderCharts();
  };
  const goNext = () => {
    const total = allDates.length;
    if (total <= DATE_WINDOW_SIZE) return;
    const maxStart = total - DATE_WINDOW_SIZE;
    dateWindowPinned = true;
    dateWindowStart = Math.min(maxStart, clampDateStart(total) + DATE_WINDOW_SIZE);
    renderCharts();
  };
  document.querySelectorAll('.dates-prev').forEach(b => b.onclick = goPrev);
  document.querySelectorAll('.dates-next').forEach(b => b.onclick = goNext);
}

/********************** CSV helpers **********************/
/********************** CSV Fetch with Preload Cache **********************/
const _preloadCache = new Map();
const PERF_LOG = new URLSearchParams(window.location.search).get('perf') === '1';

async function fetchCsv(url){
  const t0 = performance.now();
  // Check preload cache first
  if (_preloadCache.has(url)) {
    const cached = _preloadCache.get(url);
    if (cached instanceof Promise) {
      const data = await cached; // Wait for in-flight request
      if (PERF_LOG) console.log(`‚è±Ô∏è ${url} ${(performance.now() - t0).toFixed(0)}ms (cached promise)`);
      return data;
    }
    if (PERF_LOG) console.log(`‚è±Ô∏è ${url} ${(performance.now() - t0).toFixed(0)}ms (cached)`);
    return cached; // Return cached data
  }
  
  // Fetch and cache
  const fetchPromise = (async () => {
    const r = await fetch(url, {cache:'default'}); // Changed from no-store to allow browser caching
    if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
    const contentType = r.headers.get('content-type') || '';
    if (contentType.includes('application/json')) {
      return await r.json();
    }
    const t = await r.text();
    return await new Promise((res,rej)=>Papa.parse(t,{header:true,skipEmptyLines:true,complete:o=>res(o.data||[]),error:e=>rej(e)}));
  })();
  
  _preloadCache.set(url, fetchPromise);
  
  try {
    const data = await fetchPromise;
    _preloadCache.set(url, data); // Replace promise with actual data
    if (PERF_LOG) console.log(`‚è±Ô∏è ${url} ${(performance.now() - t0).toFixed(0)}ms`);
    return data;
  } catch (e) {
    _preloadCache.delete(url); // Remove failed requests from cache
    if (PERF_LOG) console.log(`‚è±Ô∏è ${url} ${(performance.now() - t0).toFixed(0)}ms (error)`);
    throw e;
  }
}

async function fetchCsvAny(cands){
  for (const u of cands){ try{ const rows = await fetchCsv(u); if (Array.isArray(rows)) return rows; } catch{} }
  return [];
}

// Preload modal data in background for faster popup
function preloadModalData(date) {
  // Modal endpoints now require an entity; skip global preloading.
  console.log(`üì¶ Skipping modal preload for ${date} (entity required)`);
}

/********************** Loaders **********************/
async function loadCounts(){
  try{
    const rows = await fetchCsv(COUNTS_PATH());
    allCountsRows = rows.map(r=>({
      date: String(r.date||'').trim(),
      company: String(r.company||'').trim(),
      pos: +r.positive||0,
      neu: +r.neutral||0,
      neg: +r.negative||0
    })).filter(r=>isISODate(r.date) && r.company);
    setLoadStatus('news', 'done');
    updateDateOptions();
    if (document.getElementById('dateSelect').value) {
      renderCharts();
    }
    maybeRenderAll();
  } catch (e){
    allCountsRows = [];
    setLoadStatus('news', 'error');
  }
}
async function loadSerpDaily(){
  try{
    const rows = await fetchCsv(SERPS_DAILY_CSV());
    serpsDaily = rows.map(r=>({
      date:(r.date||'').trim(),
      company:(r.company||'').trim(),
      total:+r.total||0,
      neg_serp:+r.negative_serp||+r.neg_serp||0,
      ctrl:+r.controlled||+r.control||0
    })).filter(r=>isISODate(r.date) && r.company);
    setLoadStatus('serps', 'done');
    updateDateOptions();
    if (document.getElementById('dateSelect').value) {
      renderCharts();
    }
    maybeRenderAll();
  }catch(e){
    serpsDaily = [];
    setLoadStatus('serps', 'error');
  }
}

async function loadSerpFeaturesIndex(){
  try{
    const rows = await fetchCsv(SERP_FEATURES_INDEX_PATH());
    const ctrlRows = await fetchCsv(SERP_FEATURES_CONTROL_INDEX_PATH());
    serpFeatureIndexRows = rows.map(r=>({
      date: String(r.date||'').trim(),
      entity: String(r.entity_name||'').trim(),
      feature: String(r.feature_type||'').trim(),
      total: +r.total_count||0,
      neg: +r.negative_count||0
    })).filter(r=>isISODate(r.date) && r.entity && r.feature);
    serpFeatureControlIndexRows = ctrlRows.map(r=>({
      date: String(r.date||'').trim(),
      entity: String(r.entity_name||'').trim(),
      feature: String(r.feature_type||'').trim(),
      total: +r.total_count||0,
      ctrl: +r.controlled_count||0
    })).filter(r=>isISODate(r.date) && r.entity && r.feature);
    const d = document.getElementById('dateSelect').value;
    if (d) {
      await loadTopStoriesForDate(d);
    }
    setLoadStatus('features', 'done');
    if (document.getElementById('dateSelect').value) {
      renderCharts();
    }
  }catch(e){
    serpFeatureIndexRows = [];
    serpFeatureControlIndexRows = [];
    topStoriesNegByDate = new Map();
    setLoadStatus('features', 'error');
  }
}

async function loadTopStoriesForDate(d){
  if (!d) return;
  try{
    const topRows = await fetchCsv(SERP_FEATURES_TOP_STORIES_PATH(d));
    topStoriesNegByDate = new Map();
    topRows.forEach(r=>{
      const date = String(r.date||'').trim();
      const entity = normEntityKey(r.entity_name);
      if (!isISODate(date) || !entity) return;
      const total = +r.total_count||0;
      const neg = +r.negative_count||0;
      topStoriesNegByDate.set(`${date}|${entity}`, total > 0 ? (neg / total) : null);
    });
  }catch(e){
    topStoriesNegByDate = new Map();
  }
}

async function loadSerpFeaturesForEntity(entityName){
  if (!entityName) return [];
  if (_serpFeatureCache.has(entityName)) {
    serpFeatureEntityRows = _serpFeatureCache.get(entityName);
    serpFeatureControlEntityRows = _serpFeatureControlCache.get(entityName) || [];
    return serpFeatureEntityRows;
  }
  try{
    const rows = await fetchCsv(SERP_FEATURES_ENTITY_PATH(entityName));
    const ctrlRows = await fetchCsv(SERP_FEATURES_CONTROL_ENTITY_PATH(entityName));
    const parsed = rows.map(r=>({
      date: String(r.date||'').trim(),
      entity: String(r.entity_name||'').trim(),
      feature: String(r.feature_type||'').trim(),
      total: +r.total_count||0,
      pos: +r.positive_count||0,
      neu: +r.neutral_count||0,
      neg: +r.negative_count||0
    })).filter(r=>isISODate(r.date) && r.entity && r.feature);
    _serpFeatureCache.set(entityName, parsed);
    serpFeatureEntityRows = parsed;
    const parsedCtrl = ctrlRows.map(r=>({
      date: String(r.date||'').trim(),
      entity: String(r.entity_name||'').trim(),
      feature: String(r.feature_type||'').trim(),
      total: +r.total_count||0,
      ctrl: +r.controlled_count||0
    })).filter(r=>isISODate(r.date) && r.entity && r.feature);
    _serpFeatureControlCache.set(entityName, parsedCtrl);
    serpFeatureControlEntityRows = parsedCtrl;
    return parsed;
  }catch(e){
    serpFeatureEntityRows = [];
    serpFeatureControlEntityRows = [];
    return [];
  }
}

/********************** Risk **********************/
function computeRisk(negPct, ctrlPct){
  if (negPct == null || isNaN(negPct)) return 'N/A';
  if (negPct > 0) return 'High';
  if (ctrlPct == null || isNaN(ctrlPct)) return 'N/A';
  return ctrlPct < 0.40 ? 'Medium' : 'Low';
}

/********************** Per-date sources **********************/
function toPct01(x){
  if (x==null || x==='') return null;
  const n = +String(x).replace('%','').trim();
  if (!isFinite(n)) return null;
  return n>1 ? n/100 : n;
}
function normEntityKey(val){
  return String(val || '')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '')
    .trim();
}

async function getArticlesForDate(d){
  if (_articlesCache.has(d)) return _articlesCache.get(d);
  const map = new Map();
  if (!d) return map;
  try{
    const rows = await fetchCsv(ARTICLES_DAILY_PATH(d));
    rows.forEach(r=>{
      const company = String(r.company||'').trim();
      if (!company) return;
      let neg = toPct01(r.neg_pct);
      if (neg==null){
        const negCount = +r.negative||0;
        const tot = (+r.total) || ((+r.positive||0)+(+r.neutral||0)+negCount) || 0;
        neg = tot ? (negCount/tot) : 0;
      }
      map.set(company, { neg_pct: neg });
    });
  }catch{}
  _articlesCache.set(d,map);
  return map;
}

async function getSerpAggForDate(d){
  if (_serpAggCache.has(d)) return _serpAggCache.get(d);
  const map = new Map();
  if (!d) return map;
  try{
    const rows = await fetchCsv(SERP_PROCESSED_PATH(d));
    rows.forEach(r=>{
      const company = String(r.company||'').trim();
      if (!company) return;
      map.set(company,{ total:+r.total||0, neg_serp:+r.negative_serp||0, controlled:+r.controlled||0 });
    });
  }catch{}
  _serpAggCache.set(d,map);
  return map;
}

/********************** UI bootstrap ***********************/
async function init(){
  initLoadStatus();
  dataReady = false;
  updateChartSkeletons();
  const sel = document.getElementById('dateSelect');
  document.getElementById('filterInput').addEventListener('input', ()=>{ currentPage=1; renderAll().then(() => {
    if (filteredRows.length === 1) selectCompany(filteredRows[0].company);
  }); });
  const favBtn = document.getElementById('favoritesBtn');
  if (favBtn){
    favBtn.onclick = ()=>{
      favoritesOnly = !favoritesOnly;
      favBtn.classList.toggle('active', favoritesOnly);
      renderAll();
    };
  }
  document.getElementById('refreshBtn').onclick = async ()=>{
    const statusEl = document.getElementById('refreshStatus');
    const refreshTargets = 'News, Organic SERP, SERP Features, Negative Summary';
    if (statusEl) statusEl.textContent = `Refreshing charts: ${refreshTargets}‚Ä¶`;
    try {
      const resp = await fetch('/api/internal/refresh_aggregates', { method: 'POST' });
      if (!resp.ok) throw new Error('refresh_failed');
      const wait = async () => {
        for (let i = 0; i < 240; i++){
          const r = await fetch('/api/internal/refresh_aggregates/status');
          if (!r.ok) throw new Error('status_failed');
          const data = await r.json();
          if (data.status !== 'in_progress') return data;
          await new Promise(res => setTimeout(res, 1000));
        }
        return { status: 'timeout' };
      };
      const result = await wait();
      if (statusEl) {
        if (result.status === 'ok') {
          statusEl.textContent = `Refreshed charts: ${refreshTargets}`;
        } else if (result.status === 'skipped') {
          statusEl.textContent = `Refresh skipped (locked): ${refreshTargets}`;
        } else if (result.status === 'timeout') {
          statusEl.textContent = `Still refreshing: ${refreshTargets}`;
        } else {
          statusEl.textContent = `Refresh failed: ${refreshTargets}`;
        }
      }
    } catch (e) {
      if (statusEl) statusEl.textContent = `Refresh failed: ${refreshTargets}`;
    }
    if (statusEl) {
      setTimeout(() => {
        statusEl.textContent = '';
      }, 3000);
    }
    await init();
  };
  document.getElementById('clearBtn').onclick = ()=>{
    selectedCompany=null;
    document.getElementById('filterInput').value='';
    updateEntityUrlParam('company', null);
    renderAll();
  };
  const f500Btn = document.getElementById('fortune500Btn');
  const f1000Btn = document.getElementById('fortune1000Btn');
  if (f500Btn) f500Btn.onclick = ()=>{ setFortuneFilter('500'); };
  if (f1000Btn) f1000Btn.onclick = ()=>{ setFortuneFilter('1000'); };
  const fullHistoryBtn = document.getElementById('fullHistoryBtn');
  if (fullHistoryBtn) {
    fullHistoryBtn.onclick = async ()=>{
      if (currentDays >= FULL_DAYS) return;
      currentDays = FULL_DAYS;
      fullHistoryBtn.disabled = true;
      await Promise.all([loadCounts(), loadSerpDaily(), loadSerpFeaturesIndex()]);
      renderAll();
    };
  }
  document.getElementById('prevBtn').onclick = ()=>{ if (currentPage>1){ currentPage--; renderTable(); } };
  document.getElementById('nextBtn').onclick = ()=>{ const totalPages = Math.max(1, Math.ceil(filteredRows.length/PAGE_SIZE)); if (currentPage<totalPages){ currentPage++; renderTable(); } };

  // 2. Sorting Listeners (Define these ONCE, outside the change handler)
  document.querySelectorAll('thead th[data-key]').forEach(th=>{
    th.style.cursor='pointer';
    th.addEventListener('click', ()=>{
      const k = th.getAttribute('data-key');
      if (currentSort.key===k) currentSort.dir*=-1; else { currentSort.key=k; currentSort.dir=1; }
      renderTable();
    });
  });

  // --- [NEW] AUTO-FILTER FROM URL (Correct Location) ---
  // This runs once when the page loads
  const urlParams = new URLSearchParams(window.location.search);
  const companyParam = urlParams.get('company');
  if (companyParam) {
    const input = document.getElementById('filterInput');
    if (input) {
      input.value = companyParam;
    }
  }
  // ----------------------------------

  // 1. Date Change Listener (bind early)
  if (!sel.dataset.boundChange){
    sel.addEventListener('change', ()=>{ 
      currentPage=1; 
      selectedCompany=null; 
      if (sel.value) {
        loadTopStoriesForDate(sel.value).then(()=>{ renderAll(); });
      }
      renderAll(); 
      if (PRELOAD_MODAL_DATA) {
        setTimeout(()=>{ if (sel.value) preloadModalData(sel.value); }, 150);
      }
    });
    sel.dataset.boundChange = '1';
  }

  renderTable();

  const idleLoad = window.requestIdleCallback || ((cb) => setTimeout(cb, 0));
  idleLoad(async () => {
    loadCounts();
    loadSerpDaily();
    loadSerpFeaturesIndex();
    loadRosterFavorites().then(()=>{ renderAll(); });
  });

  const idle = window.requestIdleCallback || ((cb) => setTimeout(cb, 0));
  idle(() => {
    loadStockData().then(data => {
      globalStockData = data;
      if (Object.keys(globalStockData).length > 0) {
        setLoadStatus('stock', 'done');
      }
      renderTable();
      return data;
    }).then(() => {
      console.log('üìà Stock data loaded. Companies with stock data:', Object.keys(globalStockData).length);
      if (Object.keys(globalStockData).length === 0) {
        console.warn('‚ö†Ô∏è  No stock data was loaded. Stock prices and sparklines will show N/A.');
      }
    }).catch(()=>{ setLoadStatus('stock','error'); });
    loadTrendsData().then(data => {
      globalTrendsData = data;
      setLoadStatus('trends', 'done');
    }).catch(()=>{ setLoadStatus('trends','error'); });
    loadNegativeSummaryIndex();
  });

  window.onclick = function(event) {
    if (event.target === document.getElementById('stockChartModal')) {
      closeStockChart();
    }
  };
}

function setFortuneFilter(next){
  fortuneFilter = (fortuneFilter === next) ? null : next;
  document.getElementById('fortune500Btn').classList.toggle('active', fortuneFilter === '500');
  document.getElementById('fortune1000Btn').classList.toggle('active', fortuneFilter === '1000');
  renderAll();
}

/********************** Data ‚Üí view rows **********************/
async function buildRowsForDate(d){
  const articles = await getArticlesForDate(d);
  const serpAgg  = await getSerpAggForDate(d);

  const out = [];
  for (const [company, a] of articles.entries()){
    const s = serpAgg.get(company);
    let negSerpPct=null, ctrlPct=null;
    if (s && s.total>0){ negSerpPct = s.neg_serp/s.total; ctrlPct = s.controlled/s.total; }
    const risk = computeRisk(negSerpPct, ctrlPct);
    const negTopStoriesPct = topStoriesNegByDate.get(`${d}|${normEntityKey(company)}`) ?? null;
    
    const stock = globalStockData[company];
    const dailyChange = stock?.dailyChange ?? null;
    
    out.push({
      date:d,
      company,
      neg_news:a.neg_pct ?? 0,
      neg_top_stories:negTopStoriesPct,
      neg_serp:negSerpPct,
      ctrl_pct:ctrlPct,
      daily_change: dailyChange,
      risk
    });
  }
  return out;
}

/********************** Rendering **********************/
async function renderAll(){
  const d = document.getElementById('dateSelect').value;
  const filter = document.getElementById('filterInput').value.trim().toLowerCase();
  if (!d) {
    filteredRows = [];
    renderTable();
    renderCharts();
    return;
  }
  const rows = (await buildRowsForDate(d)).filter(r => {
    if (filter && !r.company.toLowerCase().includes(filter)) return false;
    if (favoritesOnly && !favoriteCompanies.has(r.company)) return false;
    if (fortuneFilter === '500' && !fortuneFlags.get(r.company)?.f500) return false;
    if (fortuneFilter === '1000' && !fortuneFlags.get(r.company)?.f1000) return false;
    return true;
  });
  filteredRows = rows;
  currentPage = 1;
  if (rows.length === 1) {
    selectedCompany = rows[0].company;
    updateEntityUrlParam('company', selectedCompany);
  } else if (selectedCompany && !rows.some(r => r.company === selectedCompany)) {
    selectedCompany = null;
  }
  if (selectedCompany) {
    await loadSerpFeaturesForEntity(selectedCompany);
  }
  renderTable();
  renderCharts();
  if (selectedCompany) updateEntityUrlParam('company', selectedCompany);
  _dataRendered = true;
  maybeHideLoadStatus();
}

function renderTable(){
  const tbody = document.getElementById('tbody');
  if (!dataReady) {
    tbody.innerHTML = Array.from({length: 6}).map(() => `
      <tr class="skeleton-row">
        <td colspan="12"><div class="skeleton-bar full"></div></td>
      </tr>
    `).join('');
    return;
  }
  let rows = [...filteredRows];

  if (currentSort.key){
    rows.sort((a,b)=>{
      const ka=a[currentSort.key], kb=b[currentSort.key];
      if (typeof ka==='string') return currentSort.dir*ka.localeCompare(kb);
      return currentSort.dir*((ka??-1)-(kb??-1));
    });
  }

  const start = (currentPage-1)*PAGE_SIZE;
  const pageRows = rows.slice(start, start+PAGE_SIZE);

  const rowsHTML = pageRows.map(r=>{
    const checked = (selectedCompany && selectedCompany===r.company) ? 'checked' : '';
    const stock = globalStockData[r.company];
    const ticker = companyTickers.get(r.company) || '';
    const hasTicker = Boolean(ticker);
    let stockPriceHtml = '<span class="muted">N/A</span>';
    let dailyChangeHtml = '<span class="muted">N/A</span>';
    let sparklineCellHtml = '<span class="muted">N/A</span>';

    if (stock && stock.openingPrice !== null) {
      stockPriceHtml = `<span class="stock-price">$${stock.openingPrice.toFixed(2)}</span>`;

      if (stock.dailyChange !== null) {
        const changeClass = stock.dailyChange >= 0 ? 'positive' : 'negative';
        const changeSymbol = stock.dailyChange >= 0 ? '‚ñ≤' : '‚ñº';
        dailyChangeHtml = `<span class="stock-change ${changeClass}">${changeSymbol} ${Math.abs(stock.dailyChange).toFixed(2)}%</span>`;
      }

      const sparklineId = `sparkline-${r.company.replace(/[^a-zA-Z0-9]/g, '-')}`;
      sparklineCellHtml = `<span id="${sparklineId}"></span>`;
    } else if (!hasTicker) {
      sparklineCellHtml = '<span class="muted">Privately Owned</span>';
    } else {
      sparklineCellHtml = '<span class="muted">Stock data unavailable</span>';
    }
    const favActive = favoriteCompanies.has(r.company);
    const favStar = `<button class="fav-inline ${favActive ? 'active' : ''}" data-company="${esc(r.company)}" title="Toggle favorite">‚òÖ</button>`;

    return `<tr data-company="${esc(r.company)}">
      <td>
        <div class="brand-cell-content">
          <input type="checkbox" data-company="${esc(r.company)}" class="brandCheck" ${checked} onclick="event.stopPropagation()" />
          ${favStar}
          <div class="brand-name">${esc(r.company)}</div>
        </div>
      </td>
      <td>${stockPriceHtml}</td>
      <td>${dailyChangeHtml}</td>
      <td class="sparkline-cell">${sparklineCellHtml}</td>
      <td>${fmtPct(r.neg_news)}</td>
      <td>${fmtPct(r.neg_top_stories)}</td>
      <td>${fmtPct(r.neg_serp)}</td>
      <td>${fmtPct(r.ctrl_pct)}</td>
      <td>${
        (r.risk==='High'||r.risk==='Medium'||r.risk==='Low')
          ? (r.risk==='High'
              ? '<span class="pill high">High</span>'
              : r.risk==='Medium'
                ? '<span class="pill med">Medium</span>'
                : '<span class="pill low">Low</span>')
          : '<span class="muted">N/A</span>'
      }</td>
      <td><button class="headBtn" data-company="${esc(r.company)}" onclick="event.stopPropagation()">View</button></td>
      <td><button class="serpBtn" data-company="${esc(r.company)}" onclick="event.stopPropagation()">View</button></td>
      <td><button class="serpFeatureBtn" data-company="${esc(r.company)}" onclick="event.stopPropagation()">View</button></td>
    </tr>`;
  }).join('');

  tbody.innerHTML = rowsHTML;

  tbody.querySelectorAll('.fav-inline[data-company]').forEach(btn=>{
    btn.onclick = async (e)=>{
      e.stopPropagation();
      const company = btn.dataset.company || '';
      if (!company) return;
      const next = !favoriteCompanies.has(company);
      btn.disabled = true;
      const ok = await updateFavorite('company', company, next);
      if (ok) {
        if (next) favoriteCompanies.add(company);
        else favoriteCompanies.delete(company);
        btn.classList.toggle('active', next);
        if (favoritesOnly && !next) {
          renderAll();
        }
      }
      btn.disabled = false;
    };
  });

  pageRows.forEach(r => {
    const stock = globalStockData[r.company];
    if (stock && stock.priceHistory && stock.priceHistory.length >= 2) {
      const sparklineId = `sparkline-${r.company.replace(/[^a-zA-Z0-9]/g, '-')}`;
      const container = document.getElementById(sparklineId);
      if (container) {
        const firstPrice = stock.priceHistory[0];
        const lastPrice = stock.priceHistory[stock.priceHistory.length - 1];
        const isPositive = lastPrice >= firstPrice;
        container.innerHTML = '';
        const canvas = createSparkline(stock.priceHistory, isPositive);
        if (canvas) container.appendChild(canvas);

        const sparklineCell = container.closest('td');
        if (sparklineCell) {
          sparklineCell.onclick = (e) => {
            e.stopPropagation();
            showStockChart(r.company);
          };
        }
      }
    }
  });

  tbody.querySelectorAll('.brandCheck').forEach(cb=>{
    cb.addEventListener('change', async (e)=>{
      const company = e.target.getAttribute('data-company');
      if (e.target.checked){
        selectedCompany = company;
        tbody.querySelectorAll('.brandCheck').forEach(x=>{ if (x!==e.target) x.checked=false; });
      } else selectedCompany=null;
      updateEntityUrlParam('company', selectedCompany);
      if (selectedCompany) {
        await loadSerpFeaturesForEntity(selectedCompany);
      }
      renderCharts();
    });
  });
  tbody.querySelectorAll('.serpBtn').forEach(btn=>{
    btn.onclick = async ()=> {
      const company = btn.getAttribute('data-company');
      await selectCompany(company);
      showSerp({ company });
    };
  });
  tbody.querySelectorAll('.serpFeatureBtn').forEach(btn=>{
    btn.onclick = async ()=> {
      const company = btn.getAttribute('data-company');
      await selectCompany(company);
      showSerpFeatures({ company });
    };
  });
  tbody.querySelectorAll('.headBtn').forEach(btn=>{
    btn.onclick = async ()=> {
      const company = btn.getAttribute('data-company');
      await selectCompany(company);
      showHeadlines({ company });
    };
  });

  document.getElementById('pageNo').textContent = String(currentPage);
  document.getElementById('pageTotal').textContent = String(Math.max(1, Math.ceil(filteredRows.length/PAGE_SIZE)));
}

/********************** Charts **********************/
function getDateSeries(){
  const byDateAll = new Map();
  const byDateSel = new Map();
  allCountsRows.forEach(r=>{
    const key=r.date;
    if (!byDateAll.has(key)) byDateAll.set(key,{pos:0,neu:0,neg:0});
    const all=byDateAll.get(key);
    all.pos += +r.pos||0; all.neu += +r.neu||0; all.neg += +r.neg||0;
    if (!selectedCompany || r.company===selectedCompany){
      if (!byDateSel.has(key)) byDateSel.set(key,{pos:0,neu:0,neg:0});
      const b=byDateSel.get(key);
      b.pos += +r.pos||0; b.neu += +r.neu||0; b.neg += +r.neg||0;
    }
  });

  const serpByDateAll = new Map();
  const serpByDateSel = new Map();
  serpsDaily.forEach(r=>{
    const key=r.date;
    if (!serpByDateAll.has(key)) serpByDateAll.set(key,{total:0,neg:0,ctrl:0});
    const all=serpByDateAll.get(key);
    all.total += +r.total||0; all.neg += +r.neg_serp||0; all.ctrl += +r.ctrl||0;
    if (!selectedCompany || r.company===selectedCompany){
      if (!serpByDateSel.has(key)) serpByDateSel.set(key,{total:0,neg:0,ctrl:0});
      const b=serpByDateSel.get(key);
      b.total += +r.total||0; b.neg += +r.neg_serp||0; b.ctrl += +r.ctrl||0;
    }
  });

  const dates=[...new Set([...byDateAll.keys(),...serpByDateAll.keys()])].filter(isISODate).sort();
  const newsPos=[],newsNeu=[],newsNeg=[],serpNegPct=[],serpCtrlPct=[],serpNegPctAll=[],serpCtrlPctAll=[];
  dates.forEach(d=>{
    const n=byDateSel.get(d)||{pos:0,neu:0,neg:0};
    const t=n.pos+n.neu+n.neg||0;
    newsPos.push(t? n.pos/t*100 : 0);
    newsNeu.push(t? n.neu/t*100 : 0);
    newsNeg.push(t? n.neg/t*100 : 0);

    const s=serpByDateSel.get(d)||{total:0,neg:0,ctrl:0};
    serpNegPct.push(s.total? s.neg/s.total*100 : 0);
    serpCtrlPct.push(s.total? s.ctrl/s.total*100 : 0);

    const sa=serpByDateAll.get(d)||{total:0,neg:0,ctrl:0};
    serpNegPctAll.push(sa.total? sa.neg/sa.total*100 : 0);
    serpCtrlPctAll.push(sa.total? sa.ctrl/sa.total*100 : 0);
  });
  return {dates,newsPos,newsNeu,newsNeg,serpNegPct,serpCtrlPct,serpNegPctAll,serpCtrlPctAll};
}

function getFeatureSeries(){
  const byDate = new Map();
  const totalByDate = new Map();
  const rows = selectedCompany ? serpFeatureEntityRows : serpFeatureIndexRows;
  const hasSentiment = rows.some(r => isItemFeature(r.feature));
  let order = hasSentiment ? FEATURE_ORDER_SENTIMENT : FEATURE_ORDER_BASE;
  const organicByDate = new Map();
  serpsDaily.forEach(r=>{
    if (selectedCompany && r.company !== selectedCompany) return;
    const key = r.date;
    if (!organicByDate.has(key)) organicByDate.set(key, {total:0, neg:0});
    const o = organicByDate.get(key);
    o.total += +r.total||0;
    o.neg += +r.neg_serp||0;
  });
  rows.forEach(r=>{
    if (!isItemFeature(r.feature)) return;
    const feature = r.feature;
    if (!totalByDate.has(r.date)) totalByDate.set(r.date, 0);
    totalByDate.set(r.date, totalByDate.get(r.date) + (r.total || 0));
    if (!byDate.has(r.date)) byDate.set(r.date, {});
    const bucket = byDate.get(r.date);
    if (!bucket[feature]) bucket[feature] = {neg:0};
    bucket[feature].neg += r.neg || 0;
  });
  organicByDate.forEach((o, date)=>{
    if (!totalByDate.has(date)) totalByDate.set(date, 0);
    totalByDate.set(date, totalByDate.get(date) + o.total);
    if (!byDate.has(date)) byDate.set(date, {});
    const bucket = byDate.get(date);
    if (!bucket.organic) bucket.organic = {neg:0};
    bucket.organic.neg += o.neg || 0;
  });
  const dates = [...totalByDate.keys()].filter(isISODate).sort();
  const series = {};
  order.forEach(f => { series[f] = []; });
  dates.forEach(d=>{
    const bucket = byDate.get(d) || {};
    const dayTotal = totalByDate.get(d) || 0;
    order.forEach(f=>{
      const v = bucket[f] || {neg:0};
      series[f].push(dayTotal ? (v.neg / dayTotal * 100) : 0);
    });
  });
  return {dates, series, order, countsByDate: byDate, totalsByDate: totalByDate};
}

function getFeatureControlSeries(){
  const byDate = new Map();
  const totalByDate = new Map();
  const rows = selectedCompany ? serpFeatureControlEntityRows : serpFeatureControlIndexRows;
  const order = FEATURE_ORDER_SENTIMENT;
  const organicByDate = new Map();
  serpsDaily.forEach(r=>{
    if (selectedCompany && r.company !== selectedCompany) return;
    const key = r.date;
    if (!organicByDate.has(key)) organicByDate.set(key, {total:0, ctrl:0});
    const o = organicByDate.get(key);
    o.total += +r.total||0;
    o.ctrl += +r.ctrl||0;
  });
  rows.forEach(r=>{
    if (!isItemFeature(r.feature)) return;
    const feature = r.feature;
    if (!byDate.has(r.date)) byDate.set(r.date, {});
    const bucket = byDate.get(r.date);
    if (!bucket[feature]) bucket[feature] = {ctrl:0};
    bucket[feature].ctrl += r.ctrl || 0;
    if (!totalByDate.has(r.date)) totalByDate.set(r.date, 0);
    totalByDate.set(r.date, totalByDate.get(r.date) + (r.total || 0));
  });
  organicByDate.forEach((o, date)=>{
    if (!byDate.has(date)) byDate.set(date, {});
    const bucket = byDate.get(date);
    if (!bucket.organic) bucket.organic = {ctrl:0};
    bucket.organic.ctrl += o.ctrl || 0;
    if (!totalByDate.has(date)) totalByDate.set(date, 0);
    totalByDate.set(date, totalByDate.get(date) + o.total);
  });
  const dates = [...totalByDate.keys()].filter(isISODate).sort();
  const series = {};
  order.forEach(f => { series[f] = []; });
  dates.forEach(d=>{
    const bucket = byDate.get(d) || {};
    const dayTotal = totalByDate.get(d) || 0;
    order.forEach(f=>{
      const v = bucket[f] || {ctrl:0};
      series[f].push(dayTotal ? (v.ctrl / dayTotal * 100) : 0);
    });
  });
  return {dates, series, order, countsByDate: byDate, totalsByDate: totalByDate};
}

function renderCharts(){
  const {dates, newsPos, newsNeu, newsNeg, serpNegPct, serpCtrlPct, serpNegPctAll, serpCtrlPctAll} = getDateSeries();
  const {dates: featureDates, series: featureSeries, order: featureOrder, countsByDate: featureCountsByDate} = getFeatureSeries();
  const {dates: featureCtrlDates, series: featureCtrlSeries, order: featureCtrlOrder, countsByDate: featureCtrlCountsByDate} = getFeatureControlSeries();

  const maxStart = Math.max(0, dates.length - DATE_WINDOW_SIZE);
  if (!dateWindowPinned || dateWindowStart === null){
    dateWindowStart = maxStart;
  }
  const start = clampDateStart(dates.length);
  const d  = sliceWindow(dates,       start, DATE_WINDOW_SIZE);
  const nP = sliceWindow(newsPos,     start, DATE_WINDOW_SIZE);
  const nN = sliceWindow(newsNeu,     start, DATE_WINDOW_SIZE);
  const nG = sliceWindow(newsNeg,     start, DATE_WINDOW_SIZE);
  const sN = sliceWindow(serpNegPct,  start, DATE_WINDOW_SIZE);
  const sC = sliceWindow(serpCtrlPct, start, DATE_WINDOW_SIZE);
  const sNAll = sliceWindow(serpNegPctAll, start, DATE_WINDOW_SIZE);
  const sCAll = sliceWindow(serpCtrlPctAll, start, DATE_WINDOW_SIZE);
  const featureIndex = new Map(featureDates.map((d,i)=>[d,i]));
  const fDates = d;
  const featureData = featureOrder.map(f=>{
    const arr = featureSeries[f] || [];
    return fDates.map(dt=>{
      const idx = featureIndex.get(dt);
      return idx == null ? 0 : (arr[idx] || 0);
    });
  });
  const featureCtrlIndex = new Map(featureCtrlDates.map((d,i)=>[d,i]));
  const fcDates = d;
  const featureCtrlData = featureCtrlOrder.map(f=>{
    const arr = featureCtrlSeries[f] || [];
    return fcDates.map(dt=>{
      const idx = featureCtrlIndex.get(dt);
      return idx == null ? 0 : (arr[idx] || 0);
    });
  });

  updateDateRangeUI(dates);
  hookDatePager(dates);

  const who = selectedCompany ? selectedCompany : 'Index Average';
  const pct = v => `${Math.round(v)}%`;

  const commonOpts = {
    responsive:true, maintainAspectRatio:false,
    layout:{ padding:{ bottom:24 } },
    scales:{
      x:{ ticks:{color:'#ebf2f2'}, grid:{color:'rgba(255,255,255,.05)'} },
      y:{ ticks:{color:'#ebf2f2', stepSize:20, callback:v=>pct(v)},
          grid:{color:'rgba(255,255,255,.06)'}, suggestedMin:0, suggestedMax:100 }
    },
    plugins:{
      legend:{labels:{color:'#ebf2f2'}},
      title:{display:true, text:who, color:'#ebf2f2', font:{weight:'bold', size:14},
             padding:{top:10,bottom:6}},
      tooltip:{callbacks:{label:(ctx)=>`${ctx.dataset?.label?ctx.dataset.label+': ':''}${pct(typeof ctx.parsed.y==='number'?ctx.parsed.y:ctx.parsed)}`}}
    }
  };

  const nh = document.getElementById('newsChart').getContext('2d');
  if (newsChart) newsChart.destroy();
  newsChart = new Chart(nh, {
    type:'bar',
    data:{ labels:d, datasets:[
      {label:'Positive %',data:nP, backgroundColor:'#82c618', stack:'s'},
      {label:'Neutral %', data:nN, backgroundColor:'#cfdbdd', stack:'s'},
      {label:'Negative %',data:nG, backgroundColor:'#ff8261', stack:'s'}
    ]},
    options:{...commonOpts}
  });

  const avg = (arr) => {
    const vals = arr.filter(v => Number.isFinite(v));
    if (!vals.length) return null;
    return vals.reduce((sum, v) => sum + v, 0) / vals.length;
  };
  const avgNegAll  = avg(sNAll);
  const avgCtrlAll = avg(sCAll);
  const avgNegLine  = avgNegAll == null ? [] : new Array(d.length).fill(avgNegAll);
  const avgCtrlLine = avgCtrlAll == null ? [] : new Array(d.length).fill(avgCtrlAll);

  const sh = document.getElementById('serpChart').getContext('2d');
  if (serpChart) serpChart.destroy();
  serpChart = new Chart(sh, {
    type: 'line',
    data: {
      labels: d,
      datasets: [
        {
          label: 'Daily Negative SERP %',
          data: sN,
          tension: 0.2,
          borderWidth: SOLID_WIDTH,
          fill: false,
          borderColor: NEG_COLOR,
          pointBackgroundColor: NEG_COLOR,
          pointBorderColor: NEG_COLOR
        },
        {
          label: 'Daily Control %',
          data: sC,
          tension: 0.2,
          borderWidth: SOLID_WIDTH,
          fill: false,
          borderColor: CTRL_COLOR,
          pointBackgroundColor: CTRL_COLOR,
          pointBorderColor: CTRL_COLOR
        },
        ...(avgNegLine.length ? [{
          label: 'Average Negative SERP %',
          data: avgNegLine,
          tension: 0,
          fill: false,
          borderWidth: DASH_WIDTH,
          borderDash: DASH_PATTERN,
          borderColor: NEG_COLOR,
          pointRadius: 0
        }] : []),
        ...(avgCtrlLine.length ? [{
          label: 'Average Daily Control %',
          data: avgCtrlLine,
          tension: 0,
          fill: false,
          borderWidth: DASH_WIDTH,
          borderDash: DASH_PATTERN,
          borderColor: CTRL_COLOR,
          pointRadius: 0
        }] : [])
      ]
    },
    options: { ...commonOpts }
  });

  const fh = document.getElementById('featureChart').getContext('2d');
  if (featureChart) featureChart.destroy();
  featureChart = new Chart(fh, {
    type: 'line',
    data: {
      labels: fDates,
      datasets: featureOrder.map((feature, idx) => ({
        label: FEATURE_LABELS[feature] || feature,
        data: featureData[idx],
        tension: 0.2,
        fill: true,
        borderWidth: 1,
        borderColor: FEATURE_COLORS[idx],
        backgroundColor: FEATURE_COLORS[idx] + 'b3',
        pointRadius: 0,
        stack: 'features'
      }))
    },
    options: {
      ...commonOpts,
      scales: {
        ...commonOpts.scales,
        y: { ...commonOpts.scales.y, stacked: true },
        x: { ...commonOpts.scales.x, stacked: true }
      },
      interaction: { mode: 'index', intersect: false },
      plugins: {
        ...commonOpts.plugins,
        tooltip: {
          ...commonOpts.plugins.tooltip,
          mode: 'index',
          intersect: false,
          callbacks: {
            ...commonOpts.plugins.tooltip.callbacks,
            label: (ctx) => {
              const pctVal = (typeof ctx.parsed.y === 'number') ? ctx.parsed.y : ctx.parsed;
              const date = ctx.label;
              const feature = featureOrder[ctx.datasetIndex];
              const bucket = featureCountsByDate.get(date) || {};
              const count = bucket[feature]?.neg || 0;
              return `${ctx.dataset?.label ? ctx.dataset.label + ': ' : ''}${pct(pctVal)} (${Math.round(count)})`;
            },
            footer: (items) => {
              const total = items.reduce((sum, i) => sum + (i.parsed?.y || 0), 0);
              const date = items[0]?.label;
              const bucket = date ? (featureCountsByDate.get(date) || {}) : {};
              const countTotal = Object.values(bucket).reduce((sum, v) => sum + ((v && v.neg) || 0), 0);
              return `Total negative: ${Math.round(total)}% (${Math.round(countTotal)})`;
            }
          }
        },
        title: { ...commonOpts.plugins.title, text: `${who} ‚Ä¢ SERP Feature Negative Share` }
      }
    }
  });

  const fch = document.getElementById('featureControlChart').getContext('2d');
  if (featureControlChart) featureControlChart.destroy();
  featureControlChart = new Chart(fch, {
    type: 'line',
    data: {
      labels: fcDates,
      datasets: featureCtrlOrder.map((feature, idx) => ({
        label: FEATURE_LABELS[feature] || feature,
        data: featureCtrlData[idx],
        tension: 0.2,
        fill: true,
        borderWidth: 1,
        borderColor: CONTROL_COLORS[idx % CONTROL_COLORS.length],
        backgroundColor: (CONTROL_COLORS[idx % CONTROL_COLORS.length] + 'b3'),
        pointRadius: 0,
        stack: 'features'
      }))
    },
    options: {
      ...commonOpts,
      scales: {
        ...commonOpts.scales,
        y: { ...commonOpts.scales.y, stacked: true },
        x: { ...commonOpts.scales.x, stacked: true }
      },
      interaction: { mode: 'index', intersect: false },
      plugins: {
        ...commonOpts.plugins,
        tooltip: {
          ...commonOpts.plugins.tooltip,
          mode: 'index',
          intersect: false,
          callbacks: {
            ...commonOpts.plugins.tooltip.callbacks,
            label: (ctx) => {
              const pctVal = (typeof ctx.parsed.y === 'number') ? ctx.parsed.y : ctx.parsed;
              const date = ctx.label;
              const feature = featureCtrlOrder[ctx.datasetIndex];
              const bucket = featureCtrlCountsByDate.get(date) || {};
              const count = bucket[feature]?.ctrl || 0;
              return `${ctx.dataset?.label ? ctx.dataset.label + ': ' : ''}${pct(pctVal)} (${Math.round(count)})`;
            },
            footer: (items) => {
              const total = items.reduce((sum, i) => sum + (i.parsed?.y || 0), 0);
              const date = items[0]?.label;
              const bucket = date ? (featureCtrlCountsByDate.get(date) || {}) : {};
              const countTotal = Object.values(bucket).reduce((sum, v) => sum + ((v && v.ctrl) || 0), 0);
              return `Total control: ${Math.round(total)}% (${Math.round(countTotal)})`;
            }
          }
        },
        title: { ...commonOpts.plugins.title, text: `${who} ‚Ä¢ SERP Feature Control Share` }
      }
    }
  });
}

/********************** Modals **********************/
const modal=document.getElementById('modal');
const modalTitle=document.getElementById('modalTitle');
const modalContent=document.getElementById('modalContent');
document.getElementById('modalClose').onclick=()=>modal.classList.remove('open');
modal.addEventListener('click',e=>{ if (e.target===modal) modal.classList.remove('open'); });
function openModal(title,html){ modalTitle.textContent=title; modalContent.innerHTML=html; modal.classList.add('open'); }

async function postOverride(payload){
  const res = await fetch('/api/internal/overrides', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  if (!res.ok) {
    const msg = await res.text();
    throw new Error(msg || 'Failed to save override');
  }
  return await res.json();
}

function updateCachedOverrides(mentionId, serpResultId, updates){
  const apply = (row) => {
    if (updates.sentiment_override !== undefined) {
      row.sentiment_override = updates.sentiment_override;
      if (updates.sentiment_override) row.sentiment = updates.sentiment_override;
    }
    if (updates.control_override !== undefined) {
      row.control_override = updates.control_override;
      if (updates.control_override) {
        row.controlled = updates.control_override;
        row.control_class = updates.control_override;
      }
    }
  };
  for (const rows of _modalHeadlinesCache.values()) {
    const list = rows.rows || rows;
    for (const r of list) {
      if (mentionId && String(r.mention_id || '') === mentionId) apply(r);
    }
  }
  for (const rows of _modalSerpCache.values()) {
    const list = rows.rows || rows;
    for (const r of list) {
      if (serpResultId && String(r.serp_result_id || '') === serpResultId) apply(r);
    }
  }
}

function updateCachedFeatureItems(featureItemId, updates){
  if (!featureItemId) return;
  _serpFeatureItemsCache.forEach((rows, key) => {
    if (!Array.isArray(rows)) return;
    rows.forEach(r => {
      if (String(r.id||'') !== String(featureItemId)) return;
      if (updates.sentiment_override !== undefined) {
        r.sentiment_override = updates.sentiment_override;
        if (updates.sentiment_override) r.sentiment = updates.sentiment_override;
      }
      if (updates.control_override !== undefined) {
        r.control_override = updates.control_override;
        if (updates.control_override) r.control_class = updates.control_override;
      }
    });
  });
}

function setEditFlags(card){
  const sentimentOverride = card.getAttribute('data-sentiment-override') || '';
  const controlOverride = card.getAttribute('data-control-override') || '';
  const llmLabel = card.getAttribute('data-llm-label') || '';
  const flagsHtml = flagIcons({
    sentiment_override: sentimentOverride || null,
    control_override: controlOverride || null,
    llm_label: llmLabel || null
  });
  let flagsEl = card.querySelector('.edit-flags');
  if (flagsHtml) {
    if (!flagsEl) {
      flagsEl = document.createElement('span');
      flagsEl.className = 'edit-flags';
      const statusEl = card.querySelector('.edit-status');
      if (statusEl && statusEl.parentNode) {
        statusEl.parentNode.insertBefore(flagsEl, statusEl);
      } else {
        card.appendChild(flagsEl);
      }
    }
    flagsEl.innerHTML = flagsHtml;
  } else if (flagsEl) {
    flagsEl.remove();
  }
}

modalContent.addEventListener('change', async (e) => {
  const select = e.target.closest('.edit-risk, .edit-controlled');
  if (!select) return;
  const card = select.closest('.serp-card');
  if (!card) return;
  const mentionId = card.getAttribute('data-mention-id');
  const serpResultId = card.getAttribute('data-serp-result-id');
  const serpFeatureItemId = card.getAttribute('data-serp-feature-item-id');
  const riskSel = card.querySelector('.edit-risk');
  const ctrlSel = card.querySelector('.edit-controlled');
  const riskVal = riskSel ? riskSel.value || null : null;
  const ctrlVal = ctrlSel ? (ctrlSel.value === '' ? null : (ctrlSel.value === 'true')) : null;
  const prevSentiment = card.getAttribute('data-current-sentiment') || '';
  const prevControl = card.getAttribute('data-current-control') || '';
  const prevSentimentOverride = card.getAttribute('data-sentiment-override') || '';
  const prevControlOverride = card.getAttribute('data-control-override') || '';
  const status = card.querySelector('.edit-status');
  updatePillClasses(card);
  if ((!mentionId && !serpResultId && !serpFeatureItemId) || (!riskVal && ctrlVal === null)) {
    if (status) status.textContent = 'Select a value';
    return;
  }
  if (status) status.textContent = 'Saving...';
  const controlOverride = ctrlVal === null ? null : (ctrlVal ? 'controlled' : 'uncontrolled');
  card.setAttribute('data-sentiment-override', riskVal || '');
  if (ctrlSel) {
    card.setAttribute('data-control-override', controlOverride || '');
    card.setAttribute('data-current-control', controlOverride || '');
  }
  card.setAttribute('data-current-sentiment', riskVal || '');
  if (serpFeatureItemId) {
    updateCachedFeatureItems(serpFeatureItemId, {
      sentiment_override: riskVal,
      control_override: ctrlSel ? controlOverride : undefined
    });
  } else {
    updateCachedOverrides(mentionId, serpResultId, {
      sentiment_override: riskVal,
      control_override: ctrlSel ? controlOverride : undefined
    });
  }
  setEditFlags(card);
  try {
    const mentionType = mentionId
      ? 'company_article'
      : (serpResultId ? 'serp_result' : 'serp_feature_item');
    const payload = {
      mention_type: mentionType,
      mention_id: mentionId || undefined,
      serp_result_id: serpResultId || undefined,
      serp_feature_item_id: serpFeatureItemId || undefined,
      sentiment_override: riskVal,
      control_override: controlOverride,
      note: 'dashboard edit'
    };
    await postOverride(payload);
    if (status) status.textContent = 'Saved';
  } catch (err) {
    card.setAttribute('data-sentiment-override', prevSentimentOverride);
    card.setAttribute('data-control-override', prevControlOverride);
    card.setAttribute('data-current-sentiment', prevSentiment);
    if (ctrlSel) card.setAttribute('data-current-control', prevControl);
    if (serpFeatureItemId) {
      updateCachedFeatureItems(serpFeatureItemId, {
        sentiment_override: prevSentimentOverride || null,
        control_override: ctrlSel ? (prevControlOverride || null) : undefined
      });
    } else {
      updateCachedOverrides(mentionId, serpResultId, {
        sentiment_override: prevSentimentOverride || null,
        control_override: ctrlSel ? (prevControlOverride || null) : undefined
      });
    }
    if (riskSel) riskSel.value = prevSentiment || 'neutral';
    if (ctrlSel) ctrlSel.value = prevControl ? (prevControl === 'controlled' ? 'true' : 'false') : '';
    updatePillClasses(card);
    setEditFlags(card);
    if (status) status.textContent = 'Error';
  }
});

function updatePillClasses(card){
  const riskSel = card.querySelector('.edit-risk');
  if (riskSel){
    riskSel.classList.remove('sentiment-positive','sentiment-neutral','sentiment-negative');
    if (riskSel.value) riskSel.classList.add(`sentiment-${riskSel.value}`);
  }
  const ctrlSel = card.querySelector('.edit-controlled');
  if (ctrlSel){
    ctrlSel.classList.remove('controlled','uncontrolled');
    if (ctrlSel.value === 'true') ctrlSel.classList.add('controlled');
    if (ctrlSel.value === 'false') ctrlSel.classList.add('uncontrolled');
  }
}

function flagIcons(r){
  const edited = !!(r.sentiment_override || r.control_override);
  const llm = !!(r.llm_label);
  if (!edited && !llm) return '';
  const parts = [];
  if (edited) parts.push('<span title="Manually edited">‚úèÔ∏è Manually edited</span>');
  if (llm) parts.push('<span title="AI enriched">ü§ñ AI enriched</span>');
  return parts.join(' ');
}

const _nextFrame = () => new Promise(resolve => requestAnimationFrame(resolve));

async function showHeadlines({company}){
  const d=document.getElementById('dateSelect').value;
  openModal(`Headlines ‚Äî ${esc(company)}`, `<div class="muted">Loading‚Ä¶</div>`);
  await _nextFrame();
  const cacheKey = `${d}|${company}`;
  let rows=[];
  let total = null;
  let offset = 0;
  try{
    if (_modalHeadlinesCache.has(cacheKey)) {
      const cached = _modalHeadlinesCache.get(cacheKey);
      rows = cached.rows || [];
      total = cached.total;
    } else {
      const data = await fetchCsv(HEADLINES_PATH(d, company, offset));
      rows = data.rows || data;
      total = data.total;
      _modalHeadlinesCache.set(cacheKey, { rows, total });
    }
  }catch(e){
    openModal(`Headlines ‚Äî ${esc(company)}`, `<div class="muted">Could not load headlines for ${d}.</div>`); return;
  }
  let list=rows.filter(r=>String(r.company||'').trim()===company);
  if (!list.length){ openModal(`Headlines ‚Äî ${esc(company)}`, `<div class="muted">No headlines for ${esc(company)} on ${d}.</div>`); return; }

  const renderCards = (items) => items.map(r=>{
    const url=String(r.url||'').trim();
    const mentionId=String(r.mention_id||'').trim();
    let domain=''; try{ domain=new URL(url).hostname.replace(/^www\./,''); }catch{}
    const source=esc(r.source||'');
    const sourceLabel=source || domain;
    const title=esc(r.title||domain||'(no title)');
    const link=url?`<a class="link" href="${esc(url)}" target="_blank" rel="noopener">${title}</a>`:`<span class="muted">${title}</span>`;
    const sRaw=String(r.sentiment||'').toLowerCase();
    const s=sRaw==='positive'?'positive':(sRaw==='negative'?'negative':'neutral');
    const ctrlRaw=String(r.control_override||r.control_class||'').toLowerCase();
    const ctrl=ctrlRaw==='controlled'?'controlled':(ctrlRaw==='uncontrolled'?'uncontrolled':'');
    const flags = flagIcons(r);
    return `<div class="serp-card" data-mention-id="${esc(mentionId)}" data-sentiment-override="${esc(r.sentiment_override||'')}" data-control-override="${esc(r.control_override||'')}" data-llm-label="${esc(r.llm_label||'')}" data-current-sentiment="${esc(s)}" data-current-control="${esc(ctrl)}">
      ${sourceLabel?`<div class="serp-domain">${sourceLabel}</div>`:''}
      <div class="serp-title">${link}</div>
      ${mentionId ? `<div class="edit-controls">
        <select class="edit-risk">
          <option value="positive" ${s==='positive'?'selected':''}>positive</option>
          <option value="neutral" ${s==='neutral'?'selected':''}>neutral</option>
          <option value="negative" ${s==='negative'?'selected':''}>negative</option>
        </select>
        <select class="edit-controlled">
          <option value="true" ${ctrl==='controlled'?'selected':''}>controlled</option>
          <option value="false" ${ctrl!=='controlled'?'selected':''}>uncontrolled</option>
        </select>
        ${flags?`<span class="edit-flags">${flags}</span>`:''}
        <span class="edit-status"></span>
      </div>` : `<div class="badges" style="margin-top:8px"><span class="badge ${s}">${s}</span>${ctrl?`<span class="badge ${ctrl}">${ctrl}</span>`:''}</div>`}
    </div>`;
  }).join('');

  const renderModal = () => {
    const cards = renderCards(list);
    const showMore = total ? list.length < total : list.length % MODAL_LIMIT === 0;
    const moreBtn = showMore ? `<button id="modalLoadMore" class="ghost-btn">Load more</button>` : '';
    const totalLabel = total ? `<div class="muted" style="margin-bottom:8px">Showing ${list.length} of ${total}</div>` : '';
    openModal(`Headlines ‚Äî ${esc(company)}`, `${totalLabel}<div class="serp-cards">${cards}</div>${moreBtn}`);
    const btn = modalContent.querySelector('#modalLoadMore');
    if (btn) {
      btn.onclick = async () => {
        btn.disabled = true;
        offset = list.length;
        const data = await fetchCsv(HEADLINES_PATH(d, company, offset));
        const more = data.rows || data;
        if (Array.isArray(more) && more.length) {
          rows = rows.concat(more);
          if (data.total) total = data.total;
          _modalHeadlinesCache.set(cacheKey, { rows, total });
          list = rows.filter(r=>String(r.company||'').trim()===company);
        }
        renderModal();
      };
    }
  };

  renderModal();
  modalContent.querySelectorAll('.serp-card').forEach(updatePillClasses);
}

async function showSerp({company}){
  const d=document.getElementById('dateSelect').value;
  openModal(`SERP ‚Äî ${esc(company)}`, `<div class="muted">Loading‚Ä¶</div>`);
  await _nextFrame();
  const cacheKey = `${d}|${company}`;
  let rows=[];
  let total=null;
  try{
    if (_modalSerpCache.has(cacheKey)) {
      const cached = _modalSerpCache.get(cacheKey);
      rows = cached.rows || [];
      total = cached.total;
    } else {
      const data = await fetchCsv(SERP_ROWS_PATH(d, company, 0));
      rows = data.rows || data;
      total = data.total;
      _modalSerpCache.set(cacheKey, { rows, total });
    }
  }
  catch{ openModal(`SERP ‚Äî ${esc(company)}`, `<div class="muted">Could not load SERP file for ${d}.</div>`); return; }
  if (!rows.length){ openModal(`SERP ‚Äî ${esc(company)}`, `<div class="muted">No SERP data found for ${d}.</div>`); return; }

  const canon=s=>String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim();
  const wantCo=canon(company);
  let matches=rows.filter(r=>canon(r.company)===wantCo);
  if (!matches.length){ openModal(`SERP ‚Äî ${esc(company)}`, `<div class="muted">No SERPs for ${esc(company)} on ${d}.</div>`); return; }

  const totalMatches=matches.length;
  const negCount=matches.filter(r=>String(r.sentiment||'').toLowerCase()==='negative').length;
  const ctrlCount=matches.filter(r=>(/^controlled|true|1$/i).test(String(r.controlled||''))).length;
  const negPct= totalMatches ? (negCount/totalMatches) : 0;
  const ctrlPct= totalMatches ? (ctrlCount/totalMatches) : 0;
  const risk=computeRisk(negPct,ctrlPct);

  matches.sort((a,b)=>(+a.position||9999)-(+b.position||9999));
  const renderCards = (items) => items.map(r=>{
    const url=String(r.url||'').trim();
    const serpResultId=String(r.serp_result_id||'').trim();
    let domain=''; try{ domain=new URL(url).hostname.replace(/^www\./,''); }catch{}
    const title=esc(r.title||domain||'(no title)');
    const snippet=esc(r.snippet||'');
    const s=String(r.sentiment||'neutral').toLowerCase();
    const ctrl=(/^controlled|true|1$/i).test(String(r.controlled||''))?'controlled':'uncontrolled';
    const link=url?`<a class="link" href="${esc(url)}" target="_blank" rel="noopener">${title}</a>`:`<span class="muted">${title}</span>`;
    const flags = flagIcons(r);
    return `<div class="serp-card" data-serp-result-id="${esc(serpResultId)}" data-sentiment-override="${esc(r.sentiment_override||'')}" data-control-override="${esc(r.control_override||'')}" data-llm-label="${esc(r.llm_label||'')}" data-current-sentiment="${esc(s)}" data-current-control="${esc(ctrl)}">
      ${domain?`<div class="serp-domain">${esc(domain)}</div>`:''}
      <div class="serp-title">${link}</div>
      ${snippet?`<div class="serp-snippet">${snippet}</div>`:''}
      ${serpResultId ? `<div class="edit-controls">
        <select class="edit-risk">
          <option value="positive" ${s==='positive'?'selected':''}>positive</option>
          <option value="neutral" ${s==='neutral'?'selected':''}>neutral</option>
          <option value="negative" ${s==='negative'?'selected':''}>negative</option>
        </select>
        <select class="edit-controlled">
          <option value="true" ${ctrl==='controlled'?'selected':''}>controlled</option>
          <option value="false" ${ctrl==='uncontrolled'?'selected':''}>uncontrolled</option>
        </select>
        ${flags?`<span class="edit-flags">${flags}</span>`:''}
        <span class="edit-status"></span>
      </div>` : `<div class="badges"><span class="badge ${s}">${s}</span><span class="badge ${ctrl}">${ctrl}</span></div>`}
    </div>`;
  }).join('');

  const metrics = `<div class="serp-metrics">
    <b>Negative SERP:</b> ${(negPct*100).toFixed(1)}% &nbsp;|&nbsp;
    <b>Control:</b> ${(ctrlPct*100).toFixed(1)}% &nbsp;|&nbsp;
    <b>Risk:</b> ${esc(risk)}
  </div>`;

  const renderModal = () => {
    const cards = renderCards(matches);
    const showMore = total ? matches.length < total : matches.length % MODAL_LIMIT === 0;
    const moreBtn = showMore ? `<button id="modalLoadMore" class="ghost-btn">Load more</button>` : '';
    const totalLabel = total ? `<div class="muted" style="margin:6px 0 8px">Showing ${matches.length} of ${total}</div>` : '';
    openModal(`SERP ‚Äî ${esc(company)}`, `${metrics}${totalLabel}<div class="serp-cards">${cards}</div>${moreBtn}`);
    const btn = modalContent.querySelector('#modalLoadMore');
    if (btn) {
      btn.onclick = async () => {
        btn.disabled = true;
        const offset = matches.length;
        const data = await fetchCsv(SERP_ROWS_PATH(d, company, offset));
        const more = data.rows || data;
        if (Array.isArray(more) && more.length) {
          rows = rows.concat(more);
          if (data.total) total = data.total;
          _modalSerpCache.set(cacheKey, { rows, total });
          matches = rows.filter(r=>canon(r.company)===wantCo);
        }
        renderModal();
      };
    }
  };
  renderModal();
  modalContent.querySelectorAll('.serp-card').forEach(updatePillClasses);
}

async function fetchSerpFeatureItems(date, company, feature, offset, limit){
  const featureKey = feature || FEATURE_ALL_KEY;
  const key = `${date}|${company}|${featureKey}|${offset}|${limit}`;
  if (_serpFeatureItemsCache.has(key)) return _serpFeatureItemsCache.get(key);
  const featureParam = feature === FEATURE_ALL_KEY ? '' : feature;
  const rows = await fetchCsv(SERP_FEATURE_ITEMS_PATH(date, company, featureParam, offset, limit));
  _serpFeatureItemsCache.set(key, rows);
  return rows;
}

async function showSerpFeatures({company}){
  const d = document.getElementById('dateSelect').value;
  openModal(`SERP Features ‚Äî ${esc(company)}`, `<div class="muted">Loading‚Ä¶</div>`);
  await _nextFrame();
  await loadSerpFeaturesForEntity(company);
  const totalsByFeature = new Map();
  serpFeatureEntityRows.forEach(r=>{
    if (r.date !== d || r.entity !== company) return;
    if (!isItemFeature(r.feature)) return;
    totalsByFeature.set(r.feature, (totalsByFeature.get(r.feature) || 0) + (r.total || 0));
  });
  const totalAll = FEATURE_MODAL_ORDER.reduce((sum, f) => sum + (totalsByFeature.get(f) || 0), 0);
  const options = [
    `<option value="${FEATURE_ALL_KEY}">${FEATURE_LABELS[FEATURE_ALL_KEY]} (${totalAll})</option>`,
    ...FEATURE_MODAL_ORDER.map(f=>{
      const count = totalsByFeature.get(f) ?? 0;
      const label = FEATURE_LABELS[f] || f;
      return `<option value="${f}">${label} (${count})</option>`;
    })
  ].join('');
  openModal(`SERP Features ‚Äî ${esc(company)}`, `
    <div class="serp-metrics">
      <label for="serpFeatureSelect"><b>Feature</b></label>
      <select id="serpFeatureSelect">${options}</select>
      <span id="serpFeatureTotal" class="muted" style="margin-left:12px"></span>
    </div>
    <div id="serpFeatureCounts" class="muted" style="margin-top:6px"></div>
    <div id="serpFeatureViz" class="serp-feature-viz" style="margin-top:10px">
      <div style="flex:1 1 220px;height:220px">
        <canvas id="serpFeatureSentChart"></canvas>
      </div>
      <div style="flex:1 1 220px;height:220px">
        <canvas id="serpFeatureControlChart"></canvas>
      </div>
    <div id="serpFeatureSummary" class="serp-card" style="flex:2 1 320px">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
        <h3 style="margin:0">AI Summary</h3>
        <button id="serpFeatureSummaryBtn" class="ghost-btn">Generate Summary</button>
      </div>
      <div class="serp-snippet muted" style="margin-top:8px">Summary not generated.</div>
    </div>
    </div>
    <div id="serpFeatureList" class="serp-cards"><div class="muted">Loading‚Ä¶</div></div>
    <div class="pagination" id="serpFeaturePager" style="display:none">
      <button id="serpFeatureMore">Load more</button>
    </div>
  `);
  const select = modalContent.querySelector('#serpFeatureSelect');
  const listEl = modalContent.querySelector('#serpFeatureList');
  const totalEl = modalContent.querySelector('#serpFeatureTotal');
  const countsEl = modalContent.querySelector('#serpFeatureCounts');
  const summaryEl = modalContent.querySelector('#serpFeatureSummary');
  const summaryBtn = modalContent.querySelector('#serpFeatureSummaryBtn');
  const vizEl = modalContent.querySelector('#serpFeatureViz');
  if (summaryEl) summaryEl.style.display = 'none';
  if (vizEl) vizEl.style.display = 'none';
  const sentCtx = modalContent.querySelector('#serpFeatureSentChart').getContext('2d');
  const ctrlCtx = modalContent.querySelector('#serpFeatureControlChart').getContext('2d');
  let featureSentChart = null;
  let featureCtrlChart = null;
  const pager = modalContent.querySelector('#serpFeaturePager');
  const moreBtn = modalContent.querySelector('#serpFeatureMore');
  let currentOffset = 0;

  const featuresFor = (feature) => (
    feature === FEATURE_ALL_KEY ? FEATURE_MODAL_ORDER : [feature]
  );

  const computeCountsForDate = (feature) => {
    const features = featuresFor(feature);
    let total = 0;
    let pos = 0;
    let neu = 0;
    let neg = 0;
    let ctrl = 0;
    serpFeatureEntityRows.forEach(r=>{
      if (r.date !== d || r.entity !== company) return;
      if (!features.includes(r.feature)) return;
      total += r.total || 0;
      pos += r.pos || 0;
      neu += r.neu || 0;
      neg += r.neg || 0;
    });
    serpFeatureControlEntityRows.forEach(r=>{
      if (r.date !== d || r.entity !== company) return;
      if (!features.includes(r.feature)) return;
      ctrl += r.ctrl || 0;
    });
    if (!total) return null;
    return {pos, neu, neg, ctrl, total};
  };

  async function renderFeature(reset = false){
    const feature = select.value;
    const label = FEATURE_LABELS[feature] || feature;
    if (reset){
      currentOffset = 0;
      listEl.innerHTML = '<div class="muted">Loading‚Ä¶</div>';
    }
    let rows = [];
    try{
      rows = await fetchSerpFeatureItems(d, company, feature, currentOffset, FEATURE_MODAL_LIMIT);
    }catch(e){
      listEl.innerHTML = `<div class="muted">Could not load ${label} items.</div>`;
      return;
    }
    if (!rows.length && currentOffset === 0){
      listEl.innerHTML = `<div class="muted">No ${label} items for ${esc(company)} on ${d}.</div>`;
      pager.style.display = 'none';
      return;
    }
    const cards = rows.map(r=>{
      const url = String(r.url||'').trim();
      const itemId = String(r.id||'').trim();
      let domain = String(r.domain||'').trim();
      if (!domain && url){ try{ domain=new URL(url).hostname.replace(/^www\./,''); }catch{} }
      const source = esc(r.source||'');
      const sourceLabel = source || domain;
      const title = esc(r.title||domain||'(no title)');
      const link = url ? `<a class="link" href="${esc(url)}" target="_blank" rel="noopener">${title}</a>` : `<span class="muted">${title}</span>`;
      const snippet = esc(r.snippet||'');
      const sRaw = String(r.sentiment||'').toLowerCase();
      const s = sRaw==='positive'?'positive':(sRaw==='negative'?'negative':'neutral');
      const ctrl = String(r.control_class||'').toLowerCase();
      const flags = flagIcons(r);
      const featureLabel = FEATURE_LABELS[r.feature_type] || r.feature_type || '';
      const featureFlag = featureLabel ? `<div class="serp-feature-flag">${esc(featureLabel)}</div>` : '';
      return `<div class="serp-card"
        data-serp-feature-item-id="${esc(itemId)}"
        data-sentiment-override="${esc(r.sentiment_override||'')}"
        data-control-override="${esc(r.control_override||'')}"
        data-llm-label="${esc(r.llm_label||'')}"
        data-current-sentiment="${esc(s)}"
        data-current-control="${esc(ctrl)}">
        ${featureFlag}
        <div class="serp-domain">${esc(sourceLabel || '')}</div>
        <div class="serp-title">${link}</div>
        ${snippet ? `<div class="serp-snippet">${snippet}</div>` : ''}
        ${flags ? `<div class="edit-flags">${flags}</div>` : ''}
        <div class="edit-controls">
          <select class="edit-risk">
            <option value="positive" ${s==='positive'?'selected':''}>Positive</option>
            <option value="neutral" ${s==='neutral'?'selected':''}>Neutral</option>
            <option value="negative" ${s==='negative'?'selected':''}>Negative</option>
          </select>
          <select class="edit-controlled">
            <option value="true" ${ctrl==='controlled'?'selected':''}>Controlled</option>
            <option value="false" ${ctrl!=='controlled'?'selected':''}>Uncontrolled</option>
          </select>
          <span class="edit-status muted"></span>
        </div>
      </div>`;
    }).join('');
    if (currentOffset === 0) {
      listEl.innerHTML = cards;
    } else {
      listEl.insertAdjacentHTML('beforeend', cards);
    }
    modalContent.querySelectorAll('.serp-card').forEach(updatePillClasses);
    modalContent.querySelectorAll('.serp-card').forEach(setEditFlags);
    if (rows.length === FEATURE_MODAL_LIMIT) {
      pager.style.display = 'flex';
    } else {
      pager.style.display = 'none';
    }
  }

  let featureHasItems = false;

  async function renderFeatureSeries(){
    const feature = select.value;
    if (feature === FEATURE_ALL_KEY) {
      const countsForDate = computeCountsForDate(feature);
      featureHasItems = !!(countsForDate && countsForDate.total);
      if (totalEl) {
        totalEl.textContent = countsForDate ? `Total URLs: ${countsForDate.total}` : '';
      }
      if (countsEl) {
        countsEl.textContent = countsForDate
          ? `Counts for ${d}: ${countsForDate.pos} positive, ${countsForDate.neu} neutral, ${countsForDate.neg} negative (total ${countsForDate.total})`
          : '';
      }
      if (featureSentChart) featureSentChart.destroy();
      if (featureCtrlChart) featureCtrlChart.destroy();
      if (!countsForDate || !countsForDate.total){
        if (vizEl) vizEl.style.display = 'none';
        if (summaryEl) summaryEl.style.display = 'none';
        if (countsEl) countsEl.textContent = `No items for ${d}.`;
        return;
      }
      if (vizEl) vizEl.style.display = 'flex';
      const negativeCount = countsForDate.neg;
      const sentimentData = [negativeCount, Math.max(0, countsForDate.total - negativeCount)];
      const uncontrolled = Math.max(0, countsForDate.total - countsForDate.ctrl);
      const controlData = [countsForDate.ctrl, uncontrolled];
      const pct = (n, d) => d ? Math.round((n / d) * 100) : 0;
      const sentimentPct = pct(negativeCount, countsForDate.total);
      const controlPct = pct(countsForDate.ctrl, countsForDate.total);
      const centerTextPlugin = (text) => ({
        id: `centerText-${text}`,
        afterDraw(chart) {
          const {ctx} = chart;
          if (!ctx) return;
          const {left, right, top, bottom} = chart.chartArea;
          const x = (left + right) / 2;
          const y = (top + bottom) / 2;
          ctx.save();
          ctx.fillStyle = '#ebf2f2';
          ctx.font = '600 20px "Manrope", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(text, x, y);
          ctx.restore();
        }
      });
      featureSentChart = new Chart(sentCtx, {
        type: 'doughnut',
        data: {
          labels: ['Negative', 'Other'],
          datasets: [{
            data: sentimentData,
            backgroundColor: ['#ff826166', 'rgba(207,219,221,0.08)'],
            borderColor: ['#ff8261', '#cfdbdd'],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { labels: { color: '#ebf2f2' } } }
        },
        plugins: [centerTextPlugin(`${sentimentPct}%`)]
      });
      featureCtrlChart = new Chart(ctrlCtx, {
        type: 'doughnut',
        data: {
          labels: ['Controlled', 'Uncontrolled/Unknown'],
          datasets: [{
            data: controlData,
            backgroundColor: ['#58dbed66', 'rgba(88,219,237,0.03)'],
            borderColor: ['#58dbed', '#58dbed'],
            borderWidth: [1, 2]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { labels: { color: '#ebf2f2' } } }
        },
        plugins: [centerTextPlugin(`${controlPct}%`)]
      });
      return;
    }
    let series = [];
    try{
      series = await fetchCsv(SERP_FEATURE_SERIES_PATH(company, feature, FEATURE_MODAL_DAYS));
    }catch{
      if (featureChartModal) featureChartModal.destroy();
      return;
    }
    const dates = series.map(r=>String(r.date||'').trim()).filter(isISODate);
    let countsForDate = null;
    let totalForDate = null;
    series.forEach(r=>{
      const total = +r.total_count || 0;
      const p = +r.positive_count || 0;
      const n = +r.neutral_count || 0;
      const g = +r.negative_count || 0;
      const c = +r.controlled_count || 0;
      if (String(r.date||'') === d) {
        totalForDate = total;
        countsForDate = {pos:p, neu:n, neg:g, ctrl:c, total};
      }
    });
    if (totalEl) {
      totalEl.textContent = totalForDate != null ? `Total URLs: ${totalForDate}` : '';
    }
    if (countsEl) {
      countsEl.textContent = countsForDate
        ? `Counts for ${d}: ${countsForDate.pos} positive, ${countsForDate.neu} neutral, ${countsForDate.neg} negative (total ${countsForDate.total})`
        : '';
    }
    featureHasItems = !!(countsForDate && countsForDate.total);
    if (featureSentChart) featureSentChart.destroy();
    if (featureCtrlChart) featureCtrlChart.destroy();
    if (!countsForDate || !countsForDate.total){
      if (vizEl) vizEl.style.display = 'none';
      if (summaryEl) summaryEl.style.display = 'none';
      if (countsEl) countsEl.textContent = `No items for ${d}.`;
      return;
    }
    if (vizEl) vizEl.style.display = 'flex';
    const negativeCount = countsForDate.neg;
    const sentimentData = [negativeCount, Math.max(0, countsForDate.total - negativeCount)];
    const uncontrolled = Math.max(0, countsForDate.total - countsForDate.ctrl);
    const controlData = [countsForDate.ctrl, uncontrolled];
    const pct = (n, d) => d ? Math.round((n / d) * 100) : 0;
    const sentimentPct = pct(negativeCount, countsForDate.total);
    const controlPct = pct(countsForDate.ctrl, countsForDate.total);
    const centerTextPlugin = (text) => ({
      id: `centerText-${text}`,
      afterDraw(chart) {
        const {ctx} = chart;
        if (!ctx) return;
        const {left, right, top, bottom} = chart.chartArea;
        const x = (left + right) / 2;
        const y = (top + bottom) / 2;
        ctx.save();
        ctx.fillStyle = '#ebf2f2';
        ctx.font = '600 20px "Manrope", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x, y);
        ctx.restore();
      }
    });
    featureSentChart = new Chart(sentCtx, {
      type: 'doughnut',
      data: {
        labels: ['Negative', 'Other'],
        datasets: [{
          data: sentimentData,
          backgroundColor: ['#ff826166', 'rgba(207,219,221,0.08)'],
          borderColor: ['#ff8261', '#cfdbdd'],
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { labels: { color: '#ebf2f2' } } }
      },
      plugins: [centerTextPlugin(`${sentimentPct}%`)]
    });
    featureCtrlChart = new Chart(ctrlCtx, {
      type: 'doughnut',
      data: {
        labels: ['Controlled', 'Uncontrolled/Unknown'],
        datasets: [{
          data: controlData,
          backgroundColor: ['#58dbed66', 'rgba(88,219,237,0.03)'],
          borderColor: ['#58dbed', '#58dbed'],
          borderWidth: [1, 2]
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { labels: { color: '#ebf2f2' } } }
      },
      plugins: [centerTextPlugin(`${controlPct}%`)]
    });
  }

  async function renderFeatureSummary(){
    if (!summaryEl) return;
    const feature = select.value;
    if (feature === FEATURE_ALL_KEY) {
      summaryEl.style.display = 'none';
      return;
    }
    if (!featureHasItems) {
      summaryEl.style.display = 'none';
      return;
    }
    const snippetEl = summaryEl.querySelector('.serp-snippet');
    if (snippetEl) snippetEl.textContent = 'Summary not generated.';
    if (summaryBtn) {
      summaryBtn.disabled = false;
      summaryBtn.textContent = 'Generate Summary';
      summaryBtn.onclick = async () => {
        summaryBtn.disabled = true;
        summaryBtn.textContent = 'Generating‚Ä¶';
        if (snippetEl) snippetEl.textContent = 'Generating summary‚Ä¶';
        try{
          const data = await fetchCsv(`/api/internal/serp_feature_summary?date=${d}&entity=brand&entity_name=${encodeURIComponent(company)}&feature_type=${encodeURIComponent(feature)}`);
          const text = (data && data.summary) ? data.summary : '';
          if (snippetEl) snippetEl.textContent = text || 'No summary available.';
          summaryBtn.textContent = 'Regenerate Summary';
          summaryBtn.disabled = false;
        }catch{
          if (snippetEl) snippetEl.textContent = 'Summary unavailable.';
          summaryBtn.textContent = 'Generate Summary';
          summaryBtn.disabled = false;
        }
      };
    }
    summaryEl.style.display = 'block';
  }

  select.addEventListener('change', async () => {
    await renderFeatureSeries();
    await renderFeatureSummary();
    renderFeature(true);
  });
  moreBtn.addEventListener('click', () => {
    currentOffset += FEATURE_MODAL_LIMIT;
    renderFeature(false);
  });
  await renderFeatureSeries();
  await renderFeatureSummary();
  await renderFeature(true);
}

/********************** Init **********************/
init();
</script>
</body>
</html>
